{"version":3,"names":["ExternalSkin","source","this","_source","value","ILaya","loader","load","Loader","SPINE","then","templet","isCreateFromURL","items","_items","_templet","init","flush","target","skeletonData","_textures","i","length","o","attachmentStr","attachment","slot","skinStr","skin","skins","j","name","attachments","regionPage","region","page","texture","slotObj","getSkeleton","findSlot","setAttachment","ExternalSkinItem","_skin","_slot","_attachment","SpineTexture","constructor","tex","realTexture","getImage","width","_b","_a","sourceWidth","height","_d","_c","sourceHeight","setFilters","minFilter","magFilter","filterMode","window","spine","TextureFilter","Nearest","FilterMode","Point","Bilinear","bitmap","convertWrapMode","mode","TextureWrap","ClampToEdge","WrapMode","Clamp","MirroredRepeat","Mirrored","Repeat","setWraps","uWrap","vWrap","tex2D","wrapModeU","wrapModeV","SpineTemplet","Resource","super","ns","_ns","basePath","_basePath","getTexture","_parse","desc","atlasText","createURL","progress","parseAtlas","URL","getPath","getRuntimeVersion","startsWith","parseAtlas4","parseAtlas3","call","atlas","atlasLoader","AtlasAttachmentLoader","ArrayBuffer","skeletonBinary","SkeletonBinary","readSkeletonData","Uint8Array","skeletonJson","SkeletonJson","RuntimeVersion","atlasPages","TextureAtlas","path","push","url","createCallback","res","_addReference","spineTex","pages","map","setTexture","getAniNameByIndex","index","tAni","animations","getSkinIndexByName","skinName","tSkinData","n","_disposeResource","k","_removeReference","QUAD_TRIANGLES","SpineSkeletonRenderer","twoColorTint","vertexEffect","tempColor","Color","tempColor2","vertexSize","temp","Vector2","temp2","temp3","temp4","vertices","Utils","newFloatArray","renderable","numVertices","numFloats","clipper","SkeletonClipping","draw","skeleton","graphics","slotRangeStart","slotRangeEnd","premultipliedAlpha","tempPos","tempUv","tempLight","tempDark","uvs","triangles","drawOrder","attachmentColor","skeletonColor","color","inRange","clippedVertexSize","isClipping","data","clipEndWithSlot","getAttachment","RegionAttachment","computeWorldVertices","bone","renderObject","MeshAttachment","ClippingAttachment","clip","clipStart","mesh","worldVerticesLength","slotColor","finalColor","r","g","b","a","slotBlendMode","blendMode","clipTriangles","clippedVertices","Float32Array","clippedTriangles","mVertices","mUVs","colorNum","alpha","verts","v","x","y","set","transform","vi","Number","isFinite","drawTriangles","Uint16Array","Matrix","EMPTY","u","setFromColor","clipEnd","SpineSkeleton","Sprite","_currentPlayTime","_pause","_currAniName","_playbackRate","_playAudio","_soundChannelArr","trackIndex","_skinName","_animationName","_loop","externalSkins","_externalSkins","resetExternalSkin","_skeleton","Skeleton","_flushExtSkin","showSkinByName","animationName","play","loop","currentTime","_playStart","_playEnd","_duration","Error","_state","update","playState","PAUSED","PLAYING","STOPPED","reset","clear","_stateData","AnimationStateData","AnimationState","_renerer","_timeKeeper","TimeKeeper","skinIndex","showSkinByIndex","addListener","start","entry","interrupt","end","dispose","complete","event","Event","COMPLETE","eventData","audioValue","audioPath","floatValue","intValue","stringValue","time","balance","volume","LABEL","channel","SoundManager","playSound","Handler","create","_onAniSoundStoped","playbackRate","READY","LayaEnv","isPlaying","nameOrIndex","force","freshSkin","playAudio","setAnimation","trackEntry","getCurrent","animationStart","animationEnd","animationDuration","animation","duration","timer","frameLoop","_update","delta","apply","animationLast","Math","max","updateWorldTransform","getAnimNum","getSlotByName","slotName","newSkine","setSkin","setSlotsToSetupPose","stop","paused","len","isStopped","pause","resume","audioBuffer","splice","clearListeners","destroy","destroyChild","addAnimation","delay","setMix","fromNameOrIndex","toNameOrIndex","fromName","toName","getBoneByName","boneName","findBone","setSlotAttachment","attachmentName","registerLoader","task","atlasUrl","replaceFileExtension","Promise","all","fetch","ext","c","ClassUtils","regClass"],"sources":["../../src/layaAir/laya/spine/ExternalSkin.ts","../../src/layaAir/laya/spine/ExternalSkinItem.ts","../../src/layaAir/laya/spine/SpineTexture.ts","../../src/layaAir/laya/spine/SpineTemplet.ts","../../src/layaAir/laya/spine/SpineSkeletonRenderer.ts","../../src/layaAir/laya/spine/SpineSkeleton.ts","../../src/layaAir/laya/spine/SpineTempletLoader.ts","../../src/layaAir/laya/spine/ModuleDef.ts"],"sourcesContent":["import { ILaya } from \"../../ILaya\";\r\nimport { Loader } from \"../net/Loader\";\r\nimport { ExternalSkinItem } from \"./ExternalSkinItem\";\r\nimport { SpineSkeleton } from \"./SpineSkeleton\";\r\nimport { SpineTemplet } from \"./SpineTemplet\";\r\n\r\nexport class ExternalSkin {\r\n    protected _source: string;\r\n    protected _templet: SpineTemplet;\r\n    protected _items: ExternalSkinItem[];\r\n    target: SpineSkeleton;\r\n\r\n    get source(): string {\r\n        return this._source;\r\n    }\r\n\r\n    set source(value: string) {\r\n        this._source = value;\r\n        if (value) {\r\n            ILaya.loader.load(value, Loader.SPINE).then((templet: SpineTemplet) => {\r\n                if (!this._source || templet && !templet.isCreateFromURL(this._source))\r\n                    return;\r\n\r\n                this.templet = templet;\r\n            });\r\n        }\r\n        else\r\n            this.templet = null;\r\n    }\r\n\r\n    set items(value: ExternalSkinItem[]) {\r\n        this._items = value;\r\n    }\r\n    get items() {\r\n        return this._items;\r\n    }\r\n\r\n\r\n    /**\r\n    * 得到动画模板的引用\r\n    * @return templet\r\n    */\r\n    get templet(): SpineTemplet {\r\n        return this._templet;\r\n    }\r\n    set templet(value: SpineTemplet) {\r\n        this.init(value);\r\n    }\r\n    protected init(templet: SpineTemplet): void {\r\n        this._templet = templet;\r\n        if (!this._templet) {\r\n            return;\r\n        }\r\n        this.flush();\r\n    }\r\n    flush() {\r\n        if (this.target && this.target.templet && this._items && this._templet && this._templet.skeletonData) {\r\n            if (null == (this.target.templet as any)._textures) return;\r\n            for (let i = this._items.length - 1; i >= 0; i--) {\r\n                let o = this._items[i];\r\n                let attachmentStr = o.attachment;\r\n                let slot = o.slot;\r\n                let skinStr = o.skin;\r\n\r\n                if (attachmentStr && slot && skinStr) {\r\n                    let attachment: spine.Attachment = null;\r\n                    let skins = this._templet.skeletonData.skins;\r\n                    for (let j = skins.length - 1; j >= 0; j--) {\r\n                        if (skins[j].name == skinStr) {\r\n                            let skin = skins[j];\r\n                            let attachments = skin.attachments;\r\n                            for (let j = attachments.length - 1; j >= 0; j--) {\r\n                                attachment = attachments[j][attachmentStr];\r\n                                if (attachment) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (attachment) {\r\n                        let regionPage = (attachment as any).region.page;\r\n                        (this.target.templet as any)._textures[regionPage.name] = regionPage.texture;\r\n                        let slotObj = this.target.getSkeleton().findSlot(slot);\r\n                        if (slotObj) {\r\n                            slotObj.setAttachment(attachment);\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n}","export class ExternalSkinItem {\r\n    protected _skin: string;\r\n    protected _slot: string;\r\n    protected _attachment: string;\r\n\r\n    get skin() {\r\n        return this._skin;\r\n    }\r\n    set skin(value: string) {\r\n        this._skin = value;\r\n    }\r\n    set slot(value: string) {\r\n        this._slot = value;\r\n    }\r\n    get slot() {\r\n        return this._slot;\r\n    }\r\n    set attachment(value: string) {\r\n        this._attachment = value;\r\n    }\r\n    get attachment() {\r\n        return this._attachment;\r\n    }\r\n\r\n}","import { FilterMode } from \"../RenderEngine/RenderEnum/FilterMode\";\r\nimport { WrapMode } from \"../RenderEngine/RenderEnum/WrapMode\";\r\nimport { Texture } from \"../resource/Texture\";\r\nimport { Texture2D } from \"../resource/Texture2D\";\r\n\r\nexport class SpineTexture {\r\n    realTexture: Texture;\r\n\r\n    constructor(tex: Texture) {\r\n        this.realTexture = tex;\r\n    }\r\n\r\n    getImage(): Object {\r\n        return {\r\n            width: (this.realTexture?.sourceWidth) ?? 16,\r\n            height: (this.realTexture?.sourceHeight) ?? 16,\r\n        };\r\n    }\r\n\r\n    setFilters(minFilter: spine.TextureFilter, magFilter: spine.TextureFilter) {\r\n        if (!this.realTexture)\r\n            return;\r\n\r\n        let filterMode: number;\r\n        if (magFilter === window.spine.TextureFilter.Nearest)\r\n            filterMode = FilterMode.Point;\r\n        else\r\n            filterMode = FilterMode.Bilinear;\r\n        (<Texture2D>this.realTexture.bitmap).filterMode = filterMode;\r\n    }\r\n\r\n    convertWrapMode(mode: spine.TextureWrap) {\r\n        return mode == window.spine.TextureWrap.ClampToEdge ? WrapMode.Clamp : (mode == window.spine.TextureWrap.MirroredRepeat ? WrapMode.Mirrored : WrapMode.Repeat);\r\n    }\r\n\r\n    setWraps(uWrap: spine.TextureWrap, vWrap: spine.TextureWrap) {\r\n        if (!this.realTexture)\r\n            return;\r\n\r\n        let tex2D = <Texture2D>this.realTexture.bitmap;\r\n        tex2D.wrapModeU = this.convertWrapMode(uWrap);\r\n        tex2D.wrapModeV = this.convertWrapMode(vWrap);\r\n    }\r\n}","import { ILaya } from \"../../ILaya\";\r\nimport { Resource } from \"../resource/Resource\";\r\nimport { Texture } from \"../resource/Texture\";\r\nimport { URL } from \"../net/URL\";\r\nimport { ILoadURL } from \"../net/Loader\";\r\nimport { SpineTexture } from \"./SpineTexture\";\r\nimport { IBatchProgress } from \"../net/BatchProgress\";\r\n\r\n/**\r\n * Spine动画模板基类\r\n */\r\nexport class SpineTemplet extends Resource {\r\n    public static RuntimeVersion: string = \"3.8\";\r\n\r\n    public skeletonData: spine.SkeletonData;\r\n\r\n    private _textures: Record<string, SpineTexture>;\r\n    private _basePath: string;\r\n    private _ns: any;\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        this._textures = {};\r\n    }\r\n\r\n    get ns(): typeof spine {\r\n        return this._ns;\r\n    }\r\n\r\n    get basePath(): string {\r\n        return this._basePath;\r\n    }\r\n\r\n    getTexture(name: string): SpineTexture {\r\n        return this._textures[name];\r\n    }\r\n\r\n    _parse(desc: string | ArrayBuffer, atlasText: string, createURL: string, progress?: IBatchProgress): Promise<void> {\r\n        this._basePath = URL.getPath(createURL);\r\n        let version = this.getRuntimeVersion(desc);\r\n        let parseAtlas;\r\n        if (version.startsWith('4.'))\r\n            parseAtlas = this.parseAtlas4;\r\n        else\r\n            parseAtlas = this.parseAtlas3;\r\n\r\n        return parseAtlas.call(this, atlasText, progress).then((atlas: any) => {\r\n            let atlasLoader = new this._ns.AtlasAttachmentLoader(atlas);\r\n            if (desc instanceof ArrayBuffer) {\r\n                let skeletonBinary = new this._ns.SkeletonBinary(atlasLoader);\r\n                this.skeletonData = skeletonBinary.readSkeletonData(new Uint8Array(desc));\r\n            } else {\r\n                let skeletonJson = new this._ns.SkeletonJson(atlasLoader);\r\n                this.skeletonData = skeletonJson.readSkeletonData(desc);\r\n            }\r\n        });\r\n    }\r\n\r\n    private getRuntimeVersion(desc: string | ArrayBuffer): string {\r\n        this._ns = window.spine;\r\n        return SpineTemplet.RuntimeVersion;\r\n    }\r\n\r\n    private parseAtlas3(atlasText: string, progress?: IBatchProgress): Promise<spine.TextureAtlas> {\r\n        let atlasPages: Array<ILoadURL> = [];\r\n        new this._ns.TextureAtlas(atlasText, (path: string) => {\r\n            atlasPages.push({ url: this._basePath + path });\r\n            return new SpineTexture(null);\r\n        });\r\n        return ILaya.loader.load(atlasPages, null, progress?.createCallback()).then((res: Array<Texture>) => {\r\n            let i = 0;\r\n            let atlas = new this._ns.TextureAtlas(atlasText, (path: string) => {\r\n                let tex = res[i++];\r\n                if (tex)\r\n                    tex._addReference();\r\n                let spineTex = new SpineTexture(tex);\r\n                this._textures[path] = spineTex;\r\n                return spineTex;\r\n            });\r\n            return atlas;\r\n        });\r\n    }\r\n\r\n    private parseAtlas4(atlasText: string, progress?: IBatchProgress): Promise<spine.TextureAtlas> {\r\n        let atlas = new this._ns.TextureAtlas(atlasText);\r\n        return ILaya.loader.load(atlas.pages.map((page: spine.TextureAtlasPage) => this._basePath + page.name),\r\n            null, progress?.createCallback()).then((res: Array<Texture>) => {\r\n                let i = 0;\r\n                for (let page of atlas.pages) {\r\n                    let tex = res[i++];\r\n                    if (tex)\r\n                        tex._addReference();\r\n                    let spineTex = new SpineTexture(tex);\r\n                    this._textures[page.name] = spineTex;\r\n                    page.setTexture(spineTex);\r\n                }\r\n\r\n                return atlas;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * 通过索引得动画名称\r\n     * @param\tindex\r\n     * @return\r\n     */\r\n    getAniNameByIndex(index: number): string {\r\n        let tAni: any = this.skeletonData.animations[index];\r\n        if (tAni) return tAni.name;\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * 通过皮肤名字得到皮肤索引\r\n     * @param\tskinName 皮肤名称\r\n     * @return\r\n     */\r\n    getSkinIndexByName(skinName: string): number {\r\n        let skins = this.skeletonData.skins;\r\n        let tSkinData: spine.Skin;\r\n        for (let i: number = 0, n: number = skins.length; i < n; i++) {\r\n            tSkinData = skins[i];\r\n            if (tSkinData.name == skinName) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * 释放纹理\r\n     * @override\r\n     */\r\n    protected _disposeResource(): void {\r\n        for (let k in this._textures) {\r\n            this._textures[k].realTexture?._removeReference();\r\n        }\r\n    }\r\n}\r\n","import { Graphics } from \"../display/Graphics\";\r\nimport { Matrix } from \"../maths/Matrix\";\r\nimport { SpineTexture } from \"./SpineTexture\";\r\nimport { SpineTemplet } from \"./SpineTemplet\";\r\n\r\ninterface Renderable {\r\n    vertices: spine.ArrayLike<number>;\r\n    numVertices: number;\r\n    numFloats: number;\r\n}\r\n\r\nconst QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\r\n\r\nexport class SpineSkeletonRenderer {\r\n    premultipliedAlpha: boolean;\r\n    vertexEffect: spine.VertexEffect = null;\r\n    templet: SpineTemplet;\r\n\r\n    private tempColor = new window.spine.Color();\r\n    private tempColor2 = new window.spine.Color();\r\n    private vertices: ArrayLike<number>;\r\n    private vertexSize = 2 + 2 + 4;\r\n    private twoColorTint = false;\r\n    private renderable: Renderable;\r\n    private clipper: spine.SkeletonClipping;\r\n    private temp = new window.spine.Vector2();\r\n    private temp2 = new window.spine.Vector2();\r\n    private temp3 = new window.spine.Color();\r\n    private temp4 = new window.spine.Color();\r\n\r\n    constructor(templet: SpineTemplet, twoColorTint: boolean = true) {\r\n        this.twoColorTint = twoColorTint;\r\n        if (twoColorTint)\r\n            this.vertexSize += 4;\r\n        this.templet = templet;\r\n        this.vertices = templet.ns.Utils.newFloatArray(this.vertexSize * 1024);\r\n        this.renderable = { vertices: null, numVertices: 0, numFloats: 0 };\r\n        this.clipper = new templet.ns.SkeletonClipping();\r\n    }\r\n\r\n    draw(skeleton: spine.Skeleton, graphics: Graphics, slotRangeStart: number = -1, slotRangeEnd: number = -1) {\r\n        let clipper = this.clipper;\r\n        let premultipliedAlpha = this.premultipliedAlpha;\r\n        let twoColorTint = false;\r\n        let blendMode: spine.BlendMode = null;\r\n\r\n        let tempPos = this.temp;\r\n        let tempUv = this.temp2;\r\n        let tempLight = this.temp3;\r\n        let tempDark = this.temp4;\r\n\r\n        let renderable: Renderable = this.renderable;\r\n        let uvs: ArrayLike<number> = null;\r\n        let triangles: Array<number> = null;\r\n        let drawOrder = skeleton.drawOrder;\r\n        let attachmentColor: spine.Color = null;\r\n        let skeletonColor = skeleton.color;\r\n        let vertexSize = twoColorTint ? 12 : 8;\r\n        let inRange = false;\r\n\r\n        if (slotRangeStart == -1) inRange = true;\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            let clippedVertexSize = clipper.isClipping() ? 2 : vertexSize;\r\n            let slot = drawOrder[i];\r\n\r\n            if (slotRangeStart >= 0 && slotRangeStart == slot.data.index) {\r\n                inRange = true;\r\n            }\r\n\r\n            if (!inRange) {\r\n                clipper.clipEndWithSlot(slot);\r\n                continue;\r\n            }\r\n\r\n            if (slotRangeEnd >= 0 && slotRangeEnd == slot.data.index) {\r\n                inRange = false;\r\n            }\r\n\r\n            let attachment = slot.getAttachment();\r\n            let name: string = null;\r\n            let texture: SpineTexture;\r\n            if (attachment instanceof this.templet.ns.RegionAttachment) {\r\n                let region = <spine.RegionAttachment>attachment;\r\n                renderable.vertices = this.vertices;\r\n                renderable.numVertices = 4;\r\n                renderable.numFloats = clippedVertexSize << 2;\r\n                if (\"4.1\" == SpineTemplet.RuntimeVersion) {\r\n                    region.computeWorldVertices(slot as any, renderable.vertices, 0, clippedVertexSize);\r\n                } else {\r\n                    region.computeWorldVertices(slot.bone, renderable.vertices, 0, clippedVertexSize);\r\n                }\r\n                triangles = QUAD_TRIANGLES;\r\n                uvs = region.uvs;\r\n                if (\"4.1\" == SpineTemplet.RuntimeVersion) {\r\n                    name = (region.region as any).page.name;\r\n                } else {\r\n                    name = region.region.renderObject.page.name;\r\n                }\r\n                texture = this.templet.getTexture(name);\r\n                attachmentColor = region.color;\r\n            } else if (attachment instanceof this.templet.ns.MeshAttachment) {\r\n                let mesh = <spine.MeshAttachment>attachment;\r\n                renderable.vertices = this.vertices;\r\n                renderable.numVertices = (mesh.worldVerticesLength >> 1);\r\n                renderable.numFloats = renderable.numVertices * clippedVertexSize;\r\n                if (renderable.numFloats > renderable.vertices.length) {\r\n                    renderable.vertices = this.vertices = this.templet.ns.Utils.newFloatArray(renderable.numFloats);\r\n                }\r\n                mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, renderable.vertices, 0, clippedVertexSize);\r\n                triangles = mesh.triangles;\r\n                if (\"4.1\" == SpineTemplet.RuntimeVersion) {\r\n                    name = (mesh.region as any).page.name;\r\n                } else {\r\n                    name = mesh.region.renderObject.page.name;\r\n                }\r\n                texture = this.templet.getTexture(name);\r\n                uvs = mesh.uvs;\r\n                attachmentColor = mesh.color;\r\n            } else if (attachment instanceof this.templet.ns.ClippingAttachment) {\r\n                let clip = <spine.ClippingAttachment>(attachment);\r\n                clipper.clipStart(slot, clip);\r\n                continue;\r\n            } else {\r\n                clipper.clipEndWithSlot(slot);\r\n                continue;\r\n            }\r\n\r\n            if (texture != null) {\r\n                let slotColor = slot.color;\r\n                let finalColor = this.tempColor;\r\n                finalColor.r = skeletonColor.r * slotColor.r * attachmentColor.r;\r\n                finalColor.g = skeletonColor.g * slotColor.g * attachmentColor.g;\r\n                finalColor.b = skeletonColor.b * slotColor.b * attachmentColor.b;\r\n                finalColor.a = skeletonColor.a * slotColor.a * attachmentColor.a;\r\n                if (premultipliedAlpha) {\r\n                    finalColor.r *= finalColor.a;\r\n                    finalColor.g *= finalColor.a;\r\n                    finalColor.b *= finalColor.a;\r\n                }\r\n\r\n                let slotBlendMode = slot.data.blendMode;\r\n                if (slotBlendMode != blendMode) {\r\n                    blendMode = slotBlendMode;\r\n                }\r\n\r\n                if (clipper.isClipping()) {\r\n                    clipper.clipTriangles(renderable.vertices, renderable.numFloats, triangles, triangles.length, uvs, finalColor, null, twoColorTint);\r\n                    let clippedVertices = new Float32Array(clipper.clippedVertices);\r\n                    let clippedTriangles = clipper.clippedTriangles;\r\n                    let mVertices = [];\r\n                    let mUVs = [];\r\n                    let colorNum = 0xffffff;\r\n                    let alpha = 1;\r\n                    if (this.vertexEffect != null) {\r\n                        let vertexEffect = this.vertexEffect;\r\n                        let verts = clippedVertices;\r\n                        if (!twoColorTint) {\r\n                            for (let v = 0, n = clippedVertices.length; v < n; v += vertexSize) {\r\n                                tempPos.x = verts[v];\r\n                                tempPos.y = verts[v + 1];\r\n                                tempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]);\r\n                                tempUv.x = verts[v + 6];\r\n                                tempUv.y = verts[v + 7];\r\n                                tempDark.set(0, 0, 0, 0);\r\n                                vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n                                verts[v] = tempPos.x;\r\n                                verts[v + 1] = tempPos.y;\r\n                                verts[v + 2] = tempLight.r;\r\n                                verts[v + 3] = tempLight.g;\r\n                                verts[v + 4] = tempLight.b;\r\n                                verts[v + 5] = tempLight.a;\r\n                                verts[v + 6] = tempUv.x;\r\n                                verts[v + 7] = tempUv.y\r\n\r\n                                mVertices.push(verts[v], -verts[v + 1]);\r\n                                colorNum = (verts[v + 2] * 255 << 16) + (verts[v + 3] * 255 << 8) + verts[v + 4];\r\n                                alpha = verts[v + 5];\r\n                                mUVs.push(verts[v + 6], verts[v + 7]);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        let vi = 0;\r\n                        while (Number.isFinite(clippedVertices[vi + 6]) && Number.isFinite(clippedVertices[vi + 7])) {\r\n                            mVertices.push(clippedVertices[vi]);\r\n                            mVertices.push(-clippedVertices[vi + 1]);\r\n                            colorNum = (clippedVertices[vi + 2] * 255 << 16) + (clippedVertices[vi + 3] * 255 << 8) + clippedVertices[vi + 4] * 255;\r\n                            alpha = clippedVertices[vi + 5];\r\n                            mUVs.push(clippedVertices[vi + 6]);\r\n                            mUVs.push(clippedVertices[vi + 7]);\r\n                            vi += this.vertexSize;\r\n                        }\r\n                    }\r\n                    let blendMode;\r\n                    switch (slotBlendMode) {\r\n                        case 1:\r\n                            blendMode = \"light\";\r\n                            break;\r\n                        case 2:\r\n                            blendMode = \"multiply\";\r\n                            break;\r\n                        case 3:\r\n                            blendMode = \"screen\";\r\n                            break;\r\n                        default:\r\n                            blendMode = \"normal\";\r\n                    }\r\n                    graphics.drawTriangles(texture.realTexture, 0, 0, <any>mVertices, <any>mUVs, new Uint16Array(clippedTriangles), Matrix.EMPTY, alpha, colorNum, blendMode);\r\n                } else {\r\n                    let verts = renderable.vertices;\r\n                    let mVertices = [];\r\n                    let mUVs = [];\r\n                    let colorNum = 0xffffff;\r\n                    let alpha = 1;\r\n                    if (this.vertexEffect != null) {\r\n                        let vertexEffect = this.vertexEffect;\r\n                        if (!twoColorTint) {\r\n                            for (let v = 0, u = 0, n = renderable.numFloats; v < n; v += vertexSize, u += 2) {\r\n                                tempPos.x = verts[v];\r\n                                tempPos.y = verts[v + 1];\r\n                                tempUv.x = uvs[u];\r\n                                tempUv.y = uvs[u + 1]\r\n                                tempLight.setFromColor(finalColor);\r\n                                tempDark.set(0, 0, 0, 0);\r\n                                vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n                                verts[v] = tempPos.x;\r\n                                verts[v + 1] = tempPos.y;\r\n                                verts[v + 2] = tempLight.r;\r\n                                verts[v + 3] = tempLight.g;\r\n                                verts[v + 4] = tempLight.b;\r\n                                verts[v + 5] = tempLight.a;\r\n                                verts[v + 6] = tempUv.x;\r\n                                verts[v + 7] = tempUv.y\r\n\r\n                                mVertices.push(verts[v], -verts[v + 1]);\r\n                                colorNum = (verts[v + 2] * 255 << 16) + (verts[v + 3] * 255 << 8) + verts[v + 4] * 255;\r\n                                alpha = verts[v + 5];\r\n                                mUVs.push(verts[v + 6], verts[v + 7]);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (!twoColorTint) {\r\n                            for (let v = 2, u = 0, n = renderable.numFloats; v < n; v += vertexSize, u += 2) {\r\n                                verts[v] = finalColor.r;\r\n                                verts[v + 1] = finalColor.g;\r\n                                verts[v + 2] = finalColor.b;\r\n                                verts[v + 3] = finalColor.a;\r\n                                verts[v + 4] = uvs[u];\r\n                                verts[v + 5] = uvs[u + 1];\r\n\r\n                                mVertices.push(verts[v - 2], -verts[v - 1]);\r\n                                colorNum = (verts[v] * 255 << 16) + (verts[v + 1] * 255 << 8) + verts[v + 2] * 255;\r\n                                alpha = verts[v + 3];\r\n                                mUVs.push(verts[v + 4], verts[v + 5]);\r\n                            }\r\n                        }\r\n                    }\r\n                    let blendMode;\r\n                    switch (slotBlendMode) {\r\n                        case 1:\r\n                            blendMode = \"light\";\r\n                            break;\r\n                        case 2:\r\n                            blendMode = \"multiply\";\r\n                            break;\r\n                        case 3:\r\n                            blendMode = \"screen\";\r\n                            break;\r\n                        default:\r\n                            blendMode = \"normal\";\r\n                    }\r\n                    graphics.drawTriangles(texture.realTexture, 0, 0, <any>mVertices, <any>mUVs, new Uint16Array(triangles), Matrix.EMPTY, alpha, colorNum, blendMode);\r\n                }\r\n            }\r\n\r\n            clipper.clipEndWithSlot(slot);\r\n        }\r\n        clipper.clipEnd();\r\n    }\r\n}\r\n","import { ILaya } from \"../../ILaya\";\r\nimport { LayaEnv } from \"../../LayaEnv\";\r\nimport { Sprite } from \"../display/Sprite\";\r\nimport { Event } from \"../events/Event\";\r\nimport { SoundChannel } from \"../media/SoundChannel\";\r\nimport { SoundManager } from \"../media/SoundManager\";\r\nimport { Loader } from \"../net/Loader\";\r\nimport { Handler } from \"../utils/Handler\";\r\nimport { ExternalSkin } from \"./ExternalSkin\";\r\nimport { SpineSkeletonRenderer } from \"./SpineSkeletonRenderer\";\r\nimport { SpineTemplet } from \"./SpineTemplet\";\r\n\r\n/**动画开始播放调度\r\n * @eventType Event.PLAYED\r\n * */\r\n/*[Event(name = \"played\", type = \"laya.events.Event.PLAYED\", desc = \"动画开始播放调度\")]*/\r\n/**动画停止播放调度\r\n * @eventType Event.STOPPED\r\n * */\r\n/*[Event(name = \"stopped\", type = \"laya.events.Event.STOPPED\", desc = \"动画停止播放调度\")]*/\r\n/**动画暂停播放调度\r\n * @eventType Event.PAUSED\r\n * */\r\n/*[Event(name = \"paused\", type = \"laya.events.Event.PAUSED\", desc = \"动画暂停播放调度\")]*/\r\n/**自定义事件。\r\n * @eventType Event.LABEL\r\n */\r\n/*[Event(name = \"label\", type = \"laya.events.Event.LABEL\", desc = \"自定义事件\")]*/\r\n/**\r\n * spine动画由<code>SpineTemplet</code>，<code>SpineSkeletonRender</code>，<code>SpineSkeleton</code>三部分组成。\r\n */\r\nexport class SpineSkeleton extends Sprite {\r\n    static readonly STOPPED: number = 0;\r\n    static readonly PAUSED: number = 1;\r\n    static readonly PLAYING: number = 2;\r\n\r\n    protected _source: string;\r\n    protected _templet: SpineTemplet;\r\n    protected _timeKeeper: spine.TimeKeeper;\r\n    protected _skeleton: spine.Skeleton;\r\n    protected _state: spine.AnimationState;\r\n    protected _stateData: spine.AnimationStateData;\r\n    protected _currentPlayTime: number = 0;\r\n    protected _renerer: SpineSkeletonRenderer;\r\n\r\n    /** @internal */\r\n    private _pause: boolean = true;\r\n    /** @internal */\r\n    private _currAniName: string = null;\r\n    /** @internal 动画播放的起始时间位置*/\r\n    private _playStart: number;\r\n    /** @internal 动画播放的结束时间位置*/\r\n    private _playEnd: number;\r\n    /** @internal 动画的总时间*/\r\n    private _duration: number;\r\n    /** 播放速率*/\r\n    private _playbackRate: number = 1.0;\r\n    /** @internal */\r\n    private _playAudio: boolean = true;\r\n    /** @internal */\r\n    private _soundChannelArr: any[] = [];\r\n    // 播放轨道索引\r\n    private trackIndex: number = 0;\r\n\r\n    private _skinName: string = \"default\";\r\n    private _animationName: string = \"\";\r\n    private _loop: boolean = true;\r\n\r\n    private _externalSkins: ExternalSkin[];\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    get externalSkins() {\r\n        return this._externalSkins;\r\n    }\r\n    set externalSkins(value: ExternalSkin[]) {\r\n        if (value) {\r\n            for (let i = value.length - 1; i >= 0; i--) {\r\n                value[i].target = this;\r\n            }\r\n        }\r\n        this._externalSkins = value;\r\n    }\r\n    /**\r\n     * 重置外部加载的皮肤的样式\r\n     */\r\n    resetExternalSkin() {\r\n        if (this._skeleton) {\r\n            this._skeleton = new this._templet.ns.Skeleton(this._templet.skeletonData);\r\n            this._flushExtSkin();\r\n        }\r\n    }\r\n\r\n    get source(): string {\r\n        return this._source;\r\n    }\r\n\r\n    set source(value: string) {\r\n        this._source = value;\r\n\r\n        if (value) {\r\n            ILaya.loader.load(value, Loader.SPINE).then((templet: SpineTemplet) => {\r\n                if (!this._source || templet && !templet.isCreateFromURL(this._source))\r\n                    return;\r\n\r\n                this.templet = templet;\r\n            });\r\n        }\r\n        else\r\n            this.templet = null;\r\n    }\r\n\r\n    get skinName(): string {\r\n        return this._skinName;\r\n    }\r\n\r\n    set skinName(value: string) {\r\n        this._skinName = value;\r\n        if (this._templet)\r\n            this.showSkinByName(value);\r\n    }\r\n\r\n    get animationName(): string {\r\n        return this._animationName;\r\n    }\r\n\r\n    set animationName(value: string) {\r\n        this._animationName = value;\r\n        if (this._templet)\r\n            this.play(value, this._loop, true);\r\n    }\r\n\r\n    get loop(): boolean {\r\n        return this._loop;\r\n    }\r\n\r\n    set loop(value: boolean) {\r\n        this._loop = value;\r\n        if (this._templet)\r\n            this.play(this._animationName, this._loop, true);\r\n    }\r\n\r\n    /**\r\n     * 得到动画模板的引用\r\n     * @return templet\r\n     */\r\n    get templet(): SpineTemplet {\r\n        return this._templet;\r\n    }\r\n\r\n    /**\r\n     * \r\n     */\r\n    set templet(value: SpineTemplet) {\r\n        this.init(value);\r\n    }\r\n\r\n    /**\r\n     * 设置当前播放位置\r\n     * @param\tvalue 当前时间\r\n     */\r\n    set currentTime(value: number) {\r\n        if (!this._currAniName || !this._templet)\r\n            return;\r\n\r\n        value /= 1000;\r\n        if (value < this._playStart || (!!this._playEnd && value > this._playEnd) || value > this._duration)\r\n            throw new Error(\"AnimationPlayer: value must large than playStartTime,small than playEndTime.\");\r\n\r\n        this._state.update(value - this._currentPlayTime);\r\n        this._currentPlayTime = value;\r\n    }\r\n\r\n    /**\r\n     * 获取当前播放状态\r\n     * @return\t当前播放状态\r\n     */\r\n    get playState(): number {\r\n        if (!this._currAniName)\r\n            return SpineSkeleton.STOPPED;\r\n        if (this._pause)\r\n            return SpineSkeleton.PAUSED;\r\n        return SpineSkeleton.PLAYING;\r\n    }\r\n\r\n    protected init(templet: SpineTemplet): void {\r\n        if (this._templet) {\r\n            this.reset();\r\n            this.graphics.clear();\r\n        }\r\n\r\n        this._templet = templet;\r\n        if (!this._templet)\r\n            return;\r\n\r\n        this._templet._addReference();\r\n        this._skeleton = new templet.ns.Skeleton(this._templet.skeletonData);\r\n        this._stateData = new templet.ns.AnimationStateData(this._skeleton.data);\r\n        // 动画状态类\r\n        this._state = new templet.ns.AnimationState(this._stateData);\r\n        this._renerer = new SpineSkeletonRenderer(templet, false);\r\n        this._timeKeeper = new templet.ns.TimeKeeper();\r\n\r\n        let skinIndex = this._templet.getSkinIndexByName(this._skinName);\r\n        if (skinIndex != -1)\r\n            this.showSkinByIndex(skinIndex);\r\n\r\n        this._state.addListener({\r\n            start: (entry: any) => {\r\n                // console.log(\"started:\", entry);\r\n            },\r\n            interrupt: (entry: any) => {\r\n                // console.log(\"interrupt:\", entry);\r\n            },\r\n            end: (entry: any) => {\r\n                // console.log(\"end:\", entry);\r\n            },\r\n            dispose: (entry: any) => {\r\n                // console.log(\"dispose:\", entry);\r\n            },\r\n            complete: (entry: any) => {\r\n                // console.log(\"complete:\", entry);\r\n                if (entry.loop) { // 如果多次播放,发送complete事件\r\n                    this.event(Event.COMPLETE);\r\n                } else { // 如果只播放一次，就发送stop事件\r\n                    this._currAniName = null;\r\n                    this.event(Event.STOPPED);\r\n                }\r\n            },\r\n            event: (entry: any, event: any) => {\r\n                let eventData = {\r\n                    audioValue: event.data.audioPath,\r\n                    audioPath: event.data.audioPath,\r\n                    floatValue: event.floatValue,\r\n                    intValue: event.intValue,\r\n                    name: event.data.name,\r\n                    stringValue: event.stringValue,\r\n                    time: event.time * 1000,\r\n                    balance: event.balance,\r\n                    volume: event.volume\r\n                };\r\n                // console.log(\"event:\", entry, event);\r\n                this.event(Event.LABEL, eventData);\r\n                if (this._playAudio && eventData.audioValue) {\r\n                    let channel = SoundManager.playSound(templet.basePath + eventData.audioValue, 1, Handler.create(this, this._onAniSoundStoped), null, (this._currentPlayTime * 1000 - eventData.time) / 1000);\r\n                    SoundManager.playbackRate = this._playbackRate;\r\n                    channel && this._soundChannelArr.push(channel);\r\n                }\r\n            },\r\n        });\r\n        this._flushExtSkin();\r\n        this.event(Event.READY);\r\n\r\n        if (LayaEnv.isPlaying && this._animationName)\r\n            this.play(this._animationName, this._loop, true);\r\n    }\r\n\r\n    /**\r\n     * 播放动画\r\n     *\r\n     * @param\tnameOrIndex\t动画名字或者索引\r\n     * @param\tloop\t\t是否循环播放\r\n     * @param\tforce\t\tfalse,如果要播的动画跟上一个相同就不生效,true,强制生效\r\n     * @param\tstart\t\t起始时间\r\n     * @param\tend\t\t\t结束时间\r\n     * @param\tfreshSkin\t是否刷新皮肤数据\r\n     * @param\tplayAudio\t是否播放音频\r\n     */\r\n    play(nameOrIndex: any, loop: boolean, force: boolean = true, start: number = 0, end: number = 0, freshSkin: boolean = true, playAudio: boolean = true) {\r\n        this._playAudio = playAudio;\r\n        start /= 1000;\r\n        end /= 1000;\r\n        let animationName = nameOrIndex;\r\n        if (start < 0 || end < 0)\r\n            throw new Error(\"SpineSkeleton: start and end must large than zero.\");\r\n        if ((end !== 0) && (start > end))\r\n            throw new Error(\"SpineSkeleton: start must less than end.\");\r\n\r\n        if (typeof animationName == \"number\") {\r\n            animationName = this.getAniNameByIndex(nameOrIndex);\r\n        }\r\n\r\n        if (force || this._pause || this._currAniName != animationName) {\r\n            this._currAniName = animationName;\r\n            // 设置执行哪个动画\r\n            this._state.setAnimation(this.trackIndex, animationName, loop);\r\n            // 设置起始和结束时间\r\n            let trackEntry = this._state.getCurrent(this.trackIndex);\r\n            trackEntry.animationStart = start;\r\n            if (!!end && end < trackEntry.animationEnd)\r\n                trackEntry.animationEnd = end;\r\n\r\n            let animationDuration = trackEntry.animation.duration;\r\n            this._duration = animationDuration;\r\n            this._playStart = start;\r\n            this._playEnd = end <= animationDuration ? end : animationDuration;\r\n\r\n            if (this._pause) {\r\n                this._pause = false;\r\n                this.timer.frameLoop(1, this, this._update, null, true);\r\n            }\r\n            this._update();\r\n        }\r\n    }\r\n\r\n    private _update(): void {\r\n        this._timeKeeper.update();\r\n        let delta = this._timeKeeper.delta * this._playbackRate;\r\n        let trackEntry = this._state.getCurrent(this.trackIndex);\r\n        // 在游戏循环中，update被调用，这样AnimationState就可以跟踪时间\r\n        this._state.update(delta);\r\n        // 使用当前动画和事件设置骨架\r\n        this._state.apply(this._skeleton);\r\n\r\n        let animationLast = trackEntry.animationLast;\r\n        this._currentPlayTime = Math.max(0, animationLast);\r\n\r\n        // spine在state.apply中发送事件，开发者可能会在事件中进行destory等操作，导致无法继续执行\r\n        if (!this._state || !this._skeleton) {\r\n            return;\r\n        }\r\n        // 计算骨骼的世界SRT(world SRT)\r\n        this._skeleton.updateWorldTransform();\r\n\r\n        this.graphics.clear();\r\n        this._renerer.draw(this._skeleton, this.graphics, -1, -1);\r\n    }\r\n\r\n    private _flushExtSkin() {\r\n        if (null == this._skeleton) return;\r\n        let skins = this._externalSkins;\r\n        if (skins) {\r\n            for (let i = skins.length - 1; i >= 0; i--) {\r\n                skins[i].flush();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 得到当前动画的数量\r\n     * @return 当前动画的数量\r\n     */\r\n    getAnimNum(): number {\r\n        return this._templet.skeletonData.animations.length;\r\n    }\r\n\r\n    /**\r\n     * 得到指定动画的名字\r\n     * @param\tindex\t动画的索引\r\n     */\r\n    getAniNameByIndex(index: number): string {\r\n        return this._templet.getAniNameByIndex(index);\r\n    }\r\n\r\n    /**\r\n     * 通过名字得到插槽的引用\r\n     * @param slotName \r\n     */\r\n    getSlotByName(slotName: string) {\r\n        return this._skeleton.findSlot(slotName)\r\n    }\r\n\r\n    /**\r\n     * 设置动画播放速率\r\n     * @param\tvalue\t1为标准速率\r\n     */\r\n    playbackRate(value: number): void {\r\n        this._playbackRate = value;\r\n    }\r\n\r\n    /**\r\n     * 通过名字显示一套皮肤\r\n     * @param\tname\t皮肤的名字\r\n     */\r\n    showSkinByName(name: string): void {\r\n        this.showSkinByIndex(this._templet.getSkinIndexByName(name));\r\n    }\r\n\r\n    /**\r\n     * 通过索引显示一套皮肤\r\n     * @param\tskinIndex\t皮肤索引\r\n     */\r\n    showSkinByIndex(skinIndex: number): void {\r\n        let newSkine = this._skeleton.data.skins[skinIndex];\r\n        this._skeleton.setSkin(newSkine);\r\n        this._skeleton.setSlotsToSetupPose();\r\n    }\r\n\r\n    /**\r\n     * 停止动画\r\n     */\r\n    stop(): void {\r\n        if (!this._pause) {\r\n            this._pause = true;\r\n            this._currAniName = null;\r\n            this.timer.clear(this, this._update);\r\n            this._state.update(-this._currentPlayTime);\r\n            this._currentPlayTime = 0;\r\n            this.event(Event.STOPPED);\r\n\r\n            if (this._soundChannelArr.length > 0) { // 有正在播放的声音\r\n                this._onAniSoundStoped(true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 暂停动画的播放\r\n     */\r\n    paused(): void {\r\n        if (!this._pause) {\r\n            this._pause = true;\r\n            this.timer.clear(this, this._update);\r\n            this.event(Event.PAUSED);\r\n            if (this._soundChannelArr.length > 0) { // 有正在播放的声音\r\n                for (let len = this._soundChannelArr.length, i = 0; i < len; i++) {\r\n                    let channel = this._soundChannelArr[i];\r\n                    if (!channel.isStopped) {\r\n                        channel.pause();\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 恢复动画的播放\r\n     */\r\n    resume(): void {\r\n        if (this._pause) {\r\n            this._pause = false;\r\n            this.timer.frameLoop(1, this, this._update, null, true);\r\n            if (this._soundChannelArr.length > 0) { // 有正在播放的声音\r\n                for (let len = this._soundChannelArr.length, i = 0; i < len; i++) {\r\n                    let channel = this._soundChannelArr[i];\r\n                    if ((channel as any).audioBuffer) {\r\n                        channel.resume();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 清掉播放完成的音频\r\n     * @param force 是否强制删掉所有的声音channel\r\n     */\r\n    private _onAniSoundStoped(force: boolean): void {\r\n        for (let len = this._soundChannelArr.length, i = 0; i < len; i++) {\r\n            let channel = this._soundChannelArr[i];\r\n            if (channel.isStopped || force) {\r\n                !channel.isStopped && channel.stop();\r\n                this._soundChannelArr.splice(i, 1);\r\n                // SoundManager.removeChannel(_channel); // TODO 是否需要? 去掉有什么好处? 是否还需要其他操作?\r\n                len--; i--;\r\n            }\r\n        }\r\n    }\r\n\r\n    private reset() {\r\n        this._templet._removeReference(1);\r\n        this._templet = null;\r\n        this._timeKeeper = null;\r\n        this._skeleton = null;\r\n        this._state.clearListeners();\r\n        this._state = null;\r\n        this._renerer = null;\r\n        this._currAniName = null;\r\n        this._pause = true;\r\n        this.timer.clear(this, this._update);\r\n        if (this._soundChannelArr.length > 0)\r\n            this._onAniSoundStoped(true);\r\n    }\r\n\r\n    /**\r\n     * 销毁当前动画\r\n     * @override\r\n     */\r\n    destroy(destroyChild: boolean = true): void {\r\n        super.destroy(destroyChild);\r\n        if (this._templet)\r\n            this.reset();\r\n    }\r\n\r\n    // ------------------------------------新增加的接口----------------------------------------------------\r\n    /**\r\n     * 添加一个动画\r\n     * @param nameOrIndex   动画名字或者索引\r\n     * @param loop          是否循环播放\r\n     * @param delay         延迟调用，可以为负数\r\n     */\r\n    addAnimation(nameOrIndex: any, loop: boolean = false, delay: number = 0) {\r\n        delay /= 1000;\r\n        let animationName = nameOrIndex;\r\n        if (typeof animationName == \"number\") {\r\n            animationName = this.getAniNameByIndex(animationName);\r\n        }\r\n        this._currAniName = animationName;\r\n        this._state.addAnimation(this.trackIndex, animationName, loop, delay);\r\n    }\r\n\r\n    /**\r\n     * 设置当动画被改变时，存储混合(交叉淡出)的持续时间\r\n     * @param fromNameOrIndex \r\n     * @param toNameOrIndex \r\n     * @param duration\r\n     */\r\n    setMix(fromNameOrIndex: any, toNameOrIndex: any, duration: number) {\r\n        duration /= 1000;\r\n        let fromName = fromNameOrIndex;\r\n        if (typeof fromName == \"number\") {\r\n            fromName = this.getAniNameByIndex(fromName);\r\n        }\r\n        let toName = toNameOrIndex;\r\n        if (typeof toName == \"number\") {\r\n            toName = this.getAniNameByIndex(toName);\r\n        }\r\n        this._stateData.setMix(fromName, toName, duration);\r\n    }\r\n\r\n    /**\r\n     * 获取骨骼信息(spine.Bone)\r\n     * 注意: 获取到的是spine运行时的骨骼信息(spine.Bone)，不适用引擎的方法\r\n     * @param boneName \r\n     */\r\n    getBoneByName(boneName: string) {\r\n        return this._skeleton.findBone(boneName);\r\n    }\r\n\r\n    /**\r\n     * 获取Skeleton(spine.Skeleton)\r\n     */\r\n    getSkeleton() {\r\n        return this._skeleton;\r\n    }\r\n\r\n    /**\r\n     * 替换插槽皮肤\r\n     * @param slotName \r\n     * @param attachmentName \r\n     */\r\n    setSlotAttachment(slotName: string, attachmentName: string) {\r\n        this._skeleton.setAttachment(slotName, attachmentName);\r\n    }\r\n}","import { IResourceLoader, ILoadTask, Loader } from \"../net/Loader\";\r\nimport { Utils } from \"../utils/Utils\";\r\nimport { SpineTemplet } from \"./SpineTemplet\";\r\n\r\nclass SpineTempletLoader implements IResourceLoader {\r\n    load(task: ILoadTask) {\r\n        let atlasUrl = Utils.replaceFileExtension(task.url, \"atlas\");\r\n\r\n        return Promise.all([\r\n            task.loader.fetch(task.url, task.ext == \"skel\" ? \"arraybuffer\" : \"json\", task.progress.createCallback()),\r\n            task.loader.fetch(atlasUrl, \"text\", task.progress.createCallback())\r\n        ]).then(res => {\r\n            if (!res[0] || !res[1])\r\n                return null;\r\n\r\n            let templet = new SpineTemplet();\r\n            return templet._parse(res[0], res[1], task.url, task.progress).then(() => templet);\r\n        });\r\n    }\r\n}\r\n\r\nLoader.registerLoader([\"skel\"], SpineTempletLoader, Loader.SPINE);","import { ClassUtils } from \"../utils/ClassUtils\";\r\nimport { ExternalSkin } from \"./ExternalSkin\";\r\nimport { ExternalSkinItem } from \"./ExternalSkinItem\";\r\nimport { SpineSkeleton } from \"./SpineSkeleton\";\r\nimport \"./SpineTempletLoader\";\r\n\r\nlet c = ClassUtils.regClass;\r\n\r\nc(\"SpineSkeleton\", SpineSkeleton);\r\nc(\"ExternalSkin\", ExternalSkin);\r\nc(\"ExternalSkinItem\", ExternalSkinItem);"],"mappings":"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"}