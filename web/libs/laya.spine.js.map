{"version":3,"names":["ExternalSkin","source","this","_source","value","ILaya","loader","load","Loader","SPINE","then","templet","isCreateFromURL","items","_items","_templet","init","flush","target","skeletonData","_textures","i","length","o","attachmentStr","attachment","slot","skinStr","skin","skins","j","name","attachments","regionPage","region","page","texture","slotObj","getSkeleton","findSlot","setAttachment","ExternalSkinItem","_skin","_slot","_attachment","SpineTexture","constructor","tex","realTexture","getImage","width","_b","_a","sourceWidth","height","_d","_c","sourceHeight","setFilters","minFilter","magFilter","filterMode","window","spine","TextureFilter","Nearest","FilterMode","Point","Bilinear","bitmap","convertWrapMode","mode","TextureWrap","ClampToEdge","WrapMode","Clamp","MirroredRepeat","Mirrored","Repeat","setWraps","uWrap","vWrap","tex2D","wrapModeU","wrapModeV","SpineTemplet","Resource","super","ns","_ns","basePath","_basePath","getTexture","_parse","desc","atlasText","createURL","progress","parseAtlas","URL","getPath","getRuntimeVersion","startsWith","parseAtlas4","parseAtlas3","call","atlas","atlasLoader","AtlasAttachmentLoader","ArrayBuffer","skeletonBinary","SkeletonBinary","readSkeletonData","Uint8Array","skeletonJson","SkeletonJson","RuntimeVersion","atlasPages","TextureAtlas","path","push","url","createCallback","res","_addReference","spineTex","pages","map","setTexture","getAniNameByIndex","index","tAni","animations","getSkinIndexByName","skinName","tSkinData","n","_disposeResource","k","_removeReference","QUAD_TRIANGLES","SpineSkeletonRenderer","twoColorTint","vertexEffect","tempColor","Color","tempColor2","vertexSize","temp","Vector2","temp2","temp3","temp4","vertices","Utils","newFloatArray","renderable","numVertices","numFloats","clipper","SkeletonClipping","draw","skeleton","graphics","slotRangeStart","slotRangeEnd","premultipliedAlpha","tempPos","tempUv","tempLight","tempDark","uvs","triangles","drawOrder","attachmentColor","skeletonColor","color","inRange","clippedVertexSize","isClipping","data","clipEndWithSlot","getAttachment","RegionAttachment","computeWorldVertices","bone","renderObject","MeshAttachment","ClippingAttachment","clip","clipStart","mesh","worldVerticesLength","slotColor","finalColor","r","g","b","a","slotBlendMode","blendMode","clipTriangles","clippedVertices","Float32Array","clippedTriangles","mVertices","mUVs","colorNum","alpha","verts","v","x","y","set","transform","vi","Number","isFinite","drawTriangles","Uint16Array","Matrix","EMPTY","u","setFromColor","clipEnd","SpineSkeleton","Sprite","_currentPlayTime","_pause","_currAniName","_playbackRate","_playAudio","_soundChannelArr","trackIndex","_skinName","_animationName","_loop","externalSkins","_externalSkins","resetExternalSkin","_skeleton","Skeleton","_flushExtSkin","showSkinByName","animationName","play","loop","currentTime","_playStart","_playEnd","_duration","Error","_state","update","playState","PAUSED","PLAYING","STOPPED","reset","clear","_stateData","AnimationStateData","AnimationState","_renerer","_timeKeeper","TimeKeeper","skinIndex","showSkinByIndex","addListener","start","entry","interrupt","end","dispose","complete","event","Event","COMPLETE","eventData","audioValue","audioPath","floatValue","intValue","stringValue","time","balance","volume","LABEL","channel","SoundManager","playSound","Handler","create","_onAniSoundStoped","playbackRate","READY","LayaEnv","isPlaying","nameOrIndex","force","freshSkin","playAudio","setAnimation","trackEntry","getCurrent","animationStart","animationEnd","animationDuration","animation","duration","timer","frameLoop","_update","delta","apply","animationLast","Math","max","updateWorldTransform","getAnimNum","getSlotByName","slotName","newSkine","setSkin","setSlotsToSetupPose","stop","paused","len","isStopped","pause","resume","audioBuffer","splice","clearListeners","destroy","destroyChild","addAnimation","delay","setMix","fromNameOrIndex","toNameOrIndex","fromName","toName","getBoneByName","boneName","findBone","setSlotAttachment","attachmentName","registerLoader","task","atlasUrl","replaceFileExtension","Promise","all","fetch","ext","c","ClassUtils","regClass"],"sources":["../../src/layaAir/laya/spine/ExternalSkin.ts","../../src/layaAir/laya/spine/ExternalSkinItem.ts","../../src/layaAir/laya/spine/SpineTexture.ts","../../src/layaAir/laya/spine/SpineTemplet.ts","../../src/layaAir/laya/spine/SpineSkeletonRenderer.ts","../../src/layaAir/laya/spine/SpineSkeleton.ts","../../src/layaAir/laya/spine/SpineTempletLoader.ts","../../src/layaAir/laya/spine/ModuleDef.ts"],"sourcesContent":["import { ILaya } from \"../../ILaya\";\nimport { Loader } from \"../net/Loader\";\nimport { ExternalSkinItem } from \"./ExternalSkinItem\";\nimport { SpineSkeleton } from \"./SpineSkeleton\";\nimport { SpineTemplet } from \"./SpineTemplet\";\n\nexport class ExternalSkin {\n    protected _source: string;\n    protected _templet: SpineTemplet;\n    protected _items: ExternalSkinItem[];\n    target: SpineSkeleton;\n\n    get source(): string {\n        return this._source;\n    }\n\n    set source(value: string) {\n        this._source = value;\n        if (value) {\n            ILaya.loader.load(value, Loader.SPINE).then((templet: SpineTemplet) => {\n                if (!this._source || templet && !templet.isCreateFromURL(this._source))\n                    return;\n\n                this.templet = templet;\n            });\n        }\n        else\n            this.templet = null;\n    }\n\n    set items(value: ExternalSkinItem[]) {\n        this._items = value;\n    }\n    get items() {\n        return this._items;\n    }\n\n\n    /**\n    * 得到动画模板的引用\n    * @return templet\n    */\n    get templet(): SpineTemplet {\n        return this._templet;\n    }\n    set templet(value: SpineTemplet) {\n        this.init(value);\n    }\n    protected init(templet: SpineTemplet): void {\n        this._templet = templet;\n        if (!this._templet) {\n            return;\n        }\n        this.flush();\n    }\n    flush() {\n        if (this.target && this.target.templet && this._items && this._templet && this._templet.skeletonData) {\n            if (null == (this.target.templet as any)._textures) return;\n            for (let i = this._items.length - 1; i >= 0; i--) {\n                let o = this._items[i];\n                let attachmentStr = o.attachment;\n                let slot = o.slot;\n                let skinStr = o.skin;\n\n                if (attachmentStr && slot && skinStr) {\n                    let attachment: spine.Attachment = null;\n                    let skins = this._templet.skeletonData.skins;\n                    for (let j = skins.length - 1; j >= 0; j--) {\n                        if (skins[j].name == skinStr) {\n                            let skin = skins[j];\n                            let attachments = skin.attachments;\n                            for (let j = attachments.length - 1; j >= 0; j--) {\n                                attachment = attachments[j][attachmentStr];\n                                if (attachment) {\n                                    break;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    if (attachment) {\n                        let regionPage = (attachment as any).region.page;\n                        (this.target.templet as any)._textures[regionPage.name] = regionPage.texture;\n                        let slotObj = this.target.getSkeleton().findSlot(slot);\n                        if (slotObj) {\n                            slotObj.setAttachment(attachment);\n                        }\n                    }\n                }\n\n            }\n        }\n\n    }\n}","export class ExternalSkinItem {\n    protected _skin: string;\n    protected _slot: string;\n    protected _attachment: string;\n\n    get skin() {\n        return this._skin;\n    }\n    set skin(value: string) {\n        this._skin = value;\n    }\n    set slot(value: string) {\n        this._slot = value;\n    }\n    get slot() {\n        return this._slot;\n    }\n    set attachment(value: string) {\n        this._attachment = value;\n    }\n    get attachment() {\n        return this._attachment;\n    }\n\n}","import { FilterMode } from \"../RenderEngine/RenderEnum/FilterMode\";\nimport { WrapMode } from \"../RenderEngine/RenderEnum/WrapMode\";\nimport { Texture } from \"../resource/Texture\";\nimport { Texture2D } from \"../resource/Texture2D\";\n\nexport class SpineTexture {\n    realTexture: Texture;\n\n    constructor(tex: Texture) {\n        this.realTexture = tex;\n    }\n\n    getImage(): Object {\n        return {\n            width: (this.realTexture?.sourceWidth) ?? 16,\n            height: (this.realTexture?.sourceHeight) ?? 16,\n        };\n    }\n\n    setFilters(minFilter: spine.TextureFilter, magFilter: spine.TextureFilter) {\n        if (!this.realTexture)\n            return;\n\n        let filterMode: number;\n        if (magFilter === window.spine.TextureFilter.Nearest)\n            filterMode = FilterMode.Point;\n        else\n            filterMode = FilterMode.Bilinear;\n        (<Texture2D>this.realTexture.bitmap).filterMode = filterMode;\n    }\n\n    convertWrapMode(mode: spine.TextureWrap) {\n        return mode == window.spine.TextureWrap.ClampToEdge ? WrapMode.Clamp : (mode == window.spine.TextureWrap.MirroredRepeat ? WrapMode.Mirrored : WrapMode.Repeat);\n    }\n\n    setWraps(uWrap: spine.TextureWrap, vWrap: spine.TextureWrap) {\n        if (!this.realTexture)\n            return;\n\n        let tex2D = <Texture2D>this.realTexture.bitmap;\n        tex2D.wrapModeU = this.convertWrapMode(uWrap);\n        tex2D.wrapModeV = this.convertWrapMode(vWrap);\n    }\n}","import { ILaya } from \"../../ILaya\";\nimport { Resource } from \"../resource/Resource\";\nimport { Texture } from \"../resource/Texture\";\nimport { URL } from \"../net/URL\";\nimport { ILoadURL } from \"../net/Loader\";\nimport { SpineTexture } from \"./SpineTexture\";\nimport { IBatchProgress } from \"../net/BatchProgress\";\n\n/**\n * Spine动画模板基类\n */\nexport class SpineTemplet extends Resource {\n    public static RuntimeVersion: string = \"3.8\";\n\n    public skeletonData: spine.SkeletonData;\n\n    private _textures: Record<string, SpineTexture>;\n    private _basePath: string;\n    private _ns: any;\n\n    constructor() {\n        super();\n\n        this._textures = {};\n    }\n\n    get ns(): typeof spine {\n        return this._ns;\n    }\n\n    get basePath(): string {\n        return this._basePath;\n    }\n\n    getTexture(name: string): SpineTexture {\n        return this._textures[name];\n    }\n\n    _parse(desc: string | ArrayBuffer, atlasText: string, createURL: string, progress?: IBatchProgress): Promise<void> {\n        this._basePath = URL.getPath(createURL);\n        let version = this.getRuntimeVersion(desc);\n        let parseAtlas;\n        if (version.startsWith('4.'))\n            parseAtlas = this.parseAtlas4;\n        else\n            parseAtlas = this.parseAtlas3;\n\n        return parseAtlas.call(this, atlasText, progress).then((atlas: any) => {\n            let atlasLoader = new this._ns.AtlasAttachmentLoader(atlas);\n            if (desc instanceof ArrayBuffer) {\n                let skeletonBinary = new this._ns.SkeletonBinary(atlasLoader);\n                this.skeletonData = skeletonBinary.readSkeletonData(new Uint8Array(desc));\n            } else {\n                let skeletonJson = new this._ns.SkeletonJson(atlasLoader);\n                this.skeletonData = skeletonJson.readSkeletonData(desc);\n            }\n        });\n    }\n\n    private getRuntimeVersion(desc: string | ArrayBuffer): string {\n        this._ns = window.spine;\n        return SpineTemplet.RuntimeVersion;\n    }\n\n    private parseAtlas3(atlasText: string, progress?: IBatchProgress): Promise<spine.TextureAtlas> {\n        let atlasPages: Array<ILoadURL> = [];\n        new this._ns.TextureAtlas(atlasText, (path: string) => {\n            atlasPages.push({ url: this._basePath + path });\n            return new SpineTexture(null);\n        });\n        return ILaya.loader.load(atlasPages, null, progress?.createCallback()).then((res: Array<Texture>) => {\n            let i = 0;\n            let atlas = new this._ns.TextureAtlas(atlasText, (path: string) => {\n                let tex = res[i++];\n                if (tex)\n                    tex._addReference();\n                let spineTex = new SpineTexture(tex);\n                this._textures[path] = spineTex;\n                return spineTex;\n            });\n            return atlas;\n        });\n    }\n\n    private parseAtlas4(atlasText: string, progress?: IBatchProgress): Promise<spine.TextureAtlas> {\n        let atlas = new this._ns.TextureAtlas(atlasText);\n        return ILaya.loader.load(atlas.pages.map((page: spine.TextureAtlasPage) => this._basePath + page.name),\n            null, progress?.createCallback()).then((res: Array<Texture>) => {\n                let i = 0;\n                for (let page of atlas.pages) {\n                    let tex = res[i++];\n                    if (tex)\n                        tex._addReference();\n                    let spineTex = new SpineTexture(tex);\n                    this._textures[page.name] = spineTex;\n                    page.setTexture(spineTex);\n                }\n\n                return atlas;\n            });\n    }\n\n    /**\n     * 通过索引得动画名称\n     * @param\tindex\n     * @return\n     */\n    getAniNameByIndex(index: number): string {\n        let tAni: any = this.skeletonData.animations[index];\n        if (tAni) return tAni.name;\n        return null;\n    }\n\n    /**\n     * 通过皮肤名字得到皮肤索引\n     * @param\tskinName 皮肤名称\n     * @return\n     */\n    getSkinIndexByName(skinName: string): number {\n        let skins = this.skeletonData.skins;\n        let tSkinData: spine.Skin;\n        for (let i: number = 0, n: number = skins.length; i < n; i++) {\n            tSkinData = skins[i];\n            if (tSkinData.name == skinName) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 释放纹理\n     * @override\n     */\n    protected _disposeResource(): void {\n        for (let k in this._textures) {\n            this._textures[k].realTexture?._removeReference();\n        }\n    }\n}\n","import { Graphics } from \"../display/Graphics\";\nimport { Matrix } from \"../maths/Matrix\";\nimport { SpineTexture } from \"./SpineTexture\";\nimport { SpineTemplet } from \"./SpineTemplet\";\n\ninterface Renderable {\n    vertices: spine.ArrayLike<number>;\n    numVertices: number;\n    numFloats: number;\n}\n\nconst QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\n\nexport class SpineSkeletonRenderer {\n    premultipliedAlpha: boolean;\n    vertexEffect: spine.VertexEffect = null;\n    templet: SpineTemplet;\n\n    private tempColor = new window.spine.Color();\n    private tempColor2 = new window.spine.Color();\n    private vertices: ArrayLike<number>;\n    private vertexSize = 2 + 2 + 4;\n    private twoColorTint = false;\n    private renderable: Renderable;\n    private clipper: spine.SkeletonClipping;\n    private temp = new window.spine.Vector2();\n    private temp2 = new window.spine.Vector2();\n    private temp3 = new window.spine.Color();\n    private temp4 = new window.spine.Color();\n\n    constructor(templet: SpineTemplet, twoColorTint: boolean = true) {\n        this.twoColorTint = twoColorTint;\n        if (twoColorTint)\n            this.vertexSize += 4;\n        this.templet = templet;\n        this.vertices = templet.ns.Utils.newFloatArray(this.vertexSize * 1024);\n        this.renderable = { vertices: null, numVertices: 0, numFloats: 0 };\n        this.clipper = new templet.ns.SkeletonClipping();\n    }\n\n    draw(skeleton: spine.Skeleton, graphics: Graphics, slotRangeStart: number = -1, slotRangeEnd: number = -1) {\n        let clipper = this.clipper;\n        let premultipliedAlpha = this.premultipliedAlpha;\n        let twoColorTint = false;\n        let blendMode: spine.BlendMode = null;\n\n        let tempPos = this.temp;\n        let tempUv = this.temp2;\n        let tempLight = this.temp3;\n        let tempDark = this.temp4;\n\n        let renderable: Renderable = this.renderable;\n        let uvs: ArrayLike<number> = null;\n        let triangles: Array<number> = null;\n        let drawOrder = skeleton.drawOrder;\n        let attachmentColor: spine.Color = null;\n        let skeletonColor = skeleton.color;\n        let vertexSize = twoColorTint ? 12 : 8;\n        let inRange = false;\n\n        if (slotRangeStart == -1) inRange = true;\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            let clippedVertexSize = clipper.isClipping() ? 2 : vertexSize;\n            let slot = drawOrder[i];\n\n            if (slotRangeStart >= 0 && slotRangeStart == slot.data.index) {\n                inRange = true;\n            }\n\n            if (!inRange) {\n                clipper.clipEndWithSlot(slot);\n                continue;\n            }\n\n            if (slotRangeEnd >= 0 && slotRangeEnd == slot.data.index) {\n                inRange = false;\n            }\n\n            let attachment = slot.getAttachment();\n            let name: string = null;\n            let texture: SpineTexture;\n            if (attachment instanceof this.templet.ns.RegionAttachment) {\n                let region = <spine.RegionAttachment>attachment;\n                renderable.vertices = this.vertices;\n                renderable.numVertices = 4;\n                renderable.numFloats = clippedVertexSize << 2;\n                if (\"4.1\" == SpineTemplet.RuntimeVersion) {\n                    region.computeWorldVertices(slot as any, renderable.vertices, 0, clippedVertexSize);\n                } else {\n                    region.computeWorldVertices(slot.bone, renderable.vertices, 0, clippedVertexSize);\n                }\n                triangles = QUAD_TRIANGLES;\n                uvs = region.uvs;\n                if (\"4.1\" == SpineTemplet.RuntimeVersion) {\n                    name = (region.region as any).page.name;\n                } else {\n                    name = region.region.renderObject.page.name;\n                }\n                texture = this.templet.getTexture(name);\n                attachmentColor = region.color;\n            } else if (attachment instanceof this.templet.ns.MeshAttachment) {\n                let mesh = <spine.MeshAttachment>attachment;\n                renderable.vertices = this.vertices;\n                renderable.numVertices = (mesh.worldVerticesLength >> 1);\n                renderable.numFloats = renderable.numVertices * clippedVertexSize;\n                if (renderable.numFloats > renderable.vertices.length) {\n                    renderable.vertices = this.vertices = this.templet.ns.Utils.newFloatArray(renderable.numFloats);\n                }\n                mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, renderable.vertices, 0, clippedVertexSize);\n                triangles = mesh.triangles;\n                if (\"4.1\" == SpineTemplet.RuntimeVersion) {\n                    name = (mesh.region as any).page.name;\n                } else {\n                    name = mesh.region.renderObject.page.name;\n                }\n                texture = this.templet.getTexture(name);\n                uvs = mesh.uvs;\n                attachmentColor = mesh.color;\n            } else if (attachment instanceof this.templet.ns.ClippingAttachment) {\n                let clip = <spine.ClippingAttachment>(attachment);\n                clipper.clipStart(slot, clip);\n                continue;\n            } else {\n                clipper.clipEndWithSlot(slot);\n                continue;\n            }\n\n            if (texture != null) {\n                let slotColor = slot.color;\n                let finalColor = this.tempColor;\n                finalColor.r = skeletonColor.r * slotColor.r * attachmentColor.r;\n                finalColor.g = skeletonColor.g * slotColor.g * attachmentColor.g;\n                finalColor.b = skeletonColor.b * slotColor.b * attachmentColor.b;\n                finalColor.a = skeletonColor.a * slotColor.a * attachmentColor.a;\n                if (premultipliedAlpha) {\n                    finalColor.r *= finalColor.a;\n                    finalColor.g *= finalColor.a;\n                    finalColor.b *= finalColor.a;\n                }\n\n                let slotBlendMode = slot.data.blendMode;\n                if (slotBlendMode != blendMode) {\n                    blendMode = slotBlendMode;\n                }\n\n                if (clipper.isClipping()) {\n                    clipper.clipTriangles(renderable.vertices, renderable.numFloats, triangles, triangles.length, uvs, finalColor, null, twoColorTint);\n                    let clippedVertices = new Float32Array(clipper.clippedVertices);\n                    let clippedTriangles = clipper.clippedTriangles;\n                    let mVertices = [];\n                    let mUVs = [];\n                    let colorNum = 0xffffff;\n                    let alpha = 1;\n                    if (this.vertexEffect != null) {\n                        let vertexEffect = this.vertexEffect;\n                        let verts = clippedVertices;\n                        if (!twoColorTint) {\n                            for (let v = 0, n = clippedVertices.length; v < n; v += vertexSize) {\n                                tempPos.x = verts[v];\n                                tempPos.y = verts[v + 1];\n                                tempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]);\n                                tempUv.x = verts[v + 6];\n                                tempUv.y = verts[v + 7];\n                                tempDark.set(0, 0, 0, 0);\n                                vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\n                                verts[v] = tempPos.x;\n                                verts[v + 1] = tempPos.y;\n                                verts[v + 2] = tempLight.r;\n                                verts[v + 3] = tempLight.g;\n                                verts[v + 4] = tempLight.b;\n                                verts[v + 5] = tempLight.a;\n                                verts[v + 6] = tempUv.x;\n                                verts[v + 7] = tempUv.y\n\n                                mVertices.push(verts[v], -verts[v + 1]);\n                                colorNum = (verts[v + 2] * 255 << 16) + (verts[v + 3] * 255 << 8) + verts[v + 4];\n                                alpha = verts[v + 5];\n                                mUVs.push(verts[v + 6], verts[v + 7]);\n                            }\n                        }\n                    } else {\n                        let vi = 0;\n                        while (Number.isFinite(clippedVertices[vi + 6]) && Number.isFinite(clippedVertices[vi + 7])) {\n                            mVertices.push(clippedVertices[vi]);\n                            mVertices.push(-clippedVertices[vi + 1]);\n                            colorNum = (clippedVertices[vi + 2] * 255 << 16) + (clippedVertices[vi + 3] * 255 << 8) + clippedVertices[vi + 4] * 255;\n                            alpha = clippedVertices[vi + 5];\n                            mUVs.push(clippedVertices[vi + 6]);\n                            mUVs.push(clippedVertices[vi + 7]);\n                            vi += this.vertexSize;\n                        }\n                    }\n                    let blendMode;\n                    switch (slotBlendMode) {\n                        case 1:\n                            blendMode = \"light\";\n                            break;\n                        case 2:\n                            blendMode = \"multiply\";\n                            break;\n                        case 3:\n                            blendMode = \"screen\";\n                            break;\n                        default:\n                            blendMode = \"normal\";\n                    }\n                    graphics.drawTriangles(texture.realTexture, 0, 0, <any>mVertices, <any>mUVs, new Uint16Array(clippedTriangles), Matrix.EMPTY, alpha, colorNum, blendMode);\n                } else {\n                    let verts = renderable.vertices;\n                    let mVertices = [];\n                    let mUVs = [];\n                    let colorNum = 0xffffff;\n                    let alpha = 1;\n                    if (this.vertexEffect != null) {\n                        let vertexEffect = this.vertexEffect;\n                        if (!twoColorTint) {\n                            for (let v = 0, u = 0, n = renderable.numFloats; v < n; v += vertexSize, u += 2) {\n                                tempPos.x = verts[v];\n                                tempPos.y = verts[v + 1];\n                                tempUv.x = uvs[u];\n                                tempUv.y = uvs[u + 1]\n                                tempLight.setFromColor(finalColor);\n                                tempDark.set(0, 0, 0, 0);\n                                vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\n                                verts[v] = tempPos.x;\n                                verts[v + 1] = tempPos.y;\n                                verts[v + 2] = tempLight.r;\n                                verts[v + 3] = tempLight.g;\n                                verts[v + 4] = tempLight.b;\n                                verts[v + 5] = tempLight.a;\n                                verts[v + 6] = tempUv.x;\n                                verts[v + 7] = tempUv.y\n\n                                mVertices.push(verts[v], -verts[v + 1]);\n                                colorNum = (verts[v + 2] * 255 << 16) + (verts[v + 3] * 255 << 8) + verts[v + 4] * 255;\n                                alpha = verts[v + 5];\n                                mUVs.push(verts[v + 6], verts[v + 7]);\n                            }\n                        }\n                    } else {\n                        if (!twoColorTint) {\n                            for (let v = 2, u = 0, n = renderable.numFloats; v < n; v += vertexSize, u += 2) {\n                                verts[v] = finalColor.r;\n                                verts[v + 1] = finalColor.g;\n                                verts[v + 2] = finalColor.b;\n                                verts[v + 3] = finalColor.a;\n                                verts[v + 4] = uvs[u];\n                                verts[v + 5] = uvs[u + 1];\n\n                                mVertices.push(verts[v - 2], -verts[v - 1]);\n                                colorNum = (verts[v] * 255 << 16) + (verts[v + 1] * 255 << 8) + verts[v + 2] * 255;\n                                alpha = verts[v + 3];\n                                mUVs.push(verts[v + 4], verts[v + 5]);\n                            }\n                        }\n                    }\n                    let blendMode;\n                    switch (slotBlendMode) {\n                        case 1:\n                            blendMode = \"light\";\n                            break;\n                        case 2:\n                            blendMode = \"multiply\";\n                            break;\n                        case 3:\n                            blendMode = \"screen\";\n                            break;\n                        default:\n                            blendMode = \"normal\";\n                    }\n                    graphics.drawTriangles(texture.realTexture, 0, 0, <any>mVertices, <any>mUVs, new Uint16Array(triangles), Matrix.EMPTY, alpha, colorNum, blendMode);\n                }\n            }\n\n            clipper.clipEndWithSlot(slot);\n        }\n        clipper.clipEnd();\n    }\n}\n","import { ILaya } from \"../../ILaya\";\nimport { LayaEnv } from \"../../LayaEnv\";\nimport { Sprite } from \"../display/Sprite\";\nimport { Event } from \"../events/Event\";\nimport { SoundChannel } from \"../media/SoundChannel\";\nimport { SoundManager } from \"../media/SoundManager\";\nimport { Loader } from \"../net/Loader\";\nimport { Handler } from \"../utils/Handler\";\nimport { ExternalSkin } from \"./ExternalSkin\";\nimport { SpineSkeletonRenderer } from \"./SpineSkeletonRenderer\";\nimport { SpineTemplet } from \"./SpineTemplet\";\n\n/**动画开始播放调度\n * @eventType Event.PLAYED\n * */\n/*[Event(name = \"played\", type = \"laya.events.Event.PLAYED\", desc = \"动画开始播放调度\")]*/\n/**动画停止播放调度\n * @eventType Event.STOPPED\n * */\n/*[Event(name = \"stopped\", type = \"laya.events.Event.STOPPED\", desc = \"动画停止播放调度\")]*/\n/**动画暂停播放调度\n * @eventType Event.PAUSED\n * */\n/*[Event(name = \"paused\", type = \"laya.events.Event.PAUSED\", desc = \"动画暂停播放调度\")]*/\n/**自定义事件。\n * @eventType Event.LABEL\n */\n/*[Event(name = \"label\", type = \"laya.events.Event.LABEL\", desc = \"自定义事件\")]*/\n/**\n * spine动画由<code>SpineTemplet</code>，<code>SpineSkeletonRender</code>，<code>SpineSkeleton</code>三部分组成。\n */\nexport class SpineSkeleton extends Sprite {\n    static readonly STOPPED: number = 0;\n    static readonly PAUSED: number = 1;\n    static readonly PLAYING: number = 2;\n\n    protected _source: string;\n    protected _templet: SpineTemplet;\n    protected _timeKeeper: spine.TimeKeeper;\n    protected _skeleton: spine.Skeleton;\n    protected _state: spine.AnimationState;\n    protected _stateData: spine.AnimationStateData;\n    protected _currentPlayTime: number = 0;\n    protected _renerer: SpineSkeletonRenderer;\n\n    /** @internal */\n    private _pause: boolean = true;\n    /** @internal */\n    private _currAniName: string = null;\n    /** @internal 动画播放的起始时间位置*/\n    private _playStart: number;\n    /** @internal 动画播放的结束时间位置*/\n    private _playEnd: number;\n    /** @internal 动画的总时间*/\n    private _duration: number;\n    /** 播放速率*/\n    private _playbackRate: number = 1.0;\n    /** @internal */\n    private _playAudio: boolean = true;\n    /** @internal */\n    private _soundChannelArr: any[] = [];\n    // 播放轨道索引\n    private trackIndex: number = 0;\n\n    private _skinName: string = \"default\";\n    private _animationName: string = \"\";\n    private _loop: boolean = true;\n\n    private _externalSkins: ExternalSkin[];\n\n    constructor() {\n        super();\n    }\n\n    get externalSkins() {\n        return this._externalSkins;\n    }\n    set externalSkins(value: ExternalSkin[]) {\n        if (value) {\n            for (let i = value.length - 1; i >= 0; i--) {\n                value[i].target = this;\n            }\n        }\n        this._externalSkins = value;\n    }\n    /**\n     * 重置外部加载的皮肤的样式\n     */\n    resetExternalSkin() {\n        if (this._skeleton) {\n            this._skeleton = new this._templet.ns.Skeleton(this._templet.skeletonData);\n            this._flushExtSkin();\n        }\n    }\n\n    get source(): string {\n        return this._source;\n    }\n\n    set source(value: string) {\n        this._source = value;\n\n        if (value) {\n            ILaya.loader.load(value, Loader.SPINE).then((templet: SpineTemplet) => {\n                if (!this._source || templet && !templet.isCreateFromURL(this._source))\n                    return;\n\n                this.templet = templet;\n            });\n        }\n        else\n            this.templet = null;\n    }\n\n    get skinName(): string {\n        return this._skinName;\n    }\n\n    set skinName(value: string) {\n        this._skinName = value;\n        if (this._templet)\n            this.showSkinByName(value);\n    }\n\n    get animationName(): string {\n        return this._animationName;\n    }\n\n    set animationName(value: string) {\n        this._animationName = value;\n        if (this._templet)\n            this.play(value, this._loop, true);\n    }\n\n    get loop(): boolean {\n        return this._loop;\n    }\n\n    set loop(value: boolean) {\n        this._loop = value;\n        if (this._templet)\n            this.play(this._animationName, this._loop, true);\n    }\n\n    /**\n     * 得到动画模板的引用\n     * @return templet\n     */\n    get templet(): SpineTemplet {\n        return this._templet;\n    }\n\n    /**\n     * \n     */\n    set templet(value: SpineTemplet) {\n        this.init(value);\n    }\n\n    /**\n     * 设置当前播放位置\n     * @param\tvalue 当前时间\n     */\n    set currentTime(value: number) {\n        if (!this._currAniName || !this._templet)\n            return;\n\n        value /= 1000;\n        if (value < this._playStart || (!!this._playEnd && value > this._playEnd) || value > this._duration)\n            throw new Error(\"AnimationPlayer: value must large than playStartTime,small than playEndTime.\");\n\n        this._state.update(value - this._currentPlayTime);\n        this._currentPlayTime = value;\n    }\n\n    /**\n     * 获取当前播放状态\n     * @return\t当前播放状态\n     */\n    get playState(): number {\n        if (!this._currAniName)\n            return SpineSkeleton.STOPPED;\n        if (this._pause)\n            return SpineSkeleton.PAUSED;\n        return SpineSkeleton.PLAYING;\n    }\n\n    protected init(templet: SpineTemplet): void {\n        if (this._templet) {\n            this.reset();\n            this.graphics.clear();\n        }\n\n        this._templet = templet;\n        if (!this._templet)\n            return;\n\n        this._templet._addReference();\n        this._skeleton = new templet.ns.Skeleton(this._templet.skeletonData);\n        this._stateData = new templet.ns.AnimationStateData(this._skeleton.data);\n        // 动画状态类\n        this._state = new templet.ns.AnimationState(this._stateData);\n        this._renerer = new SpineSkeletonRenderer(templet, false);\n        this._timeKeeper = new templet.ns.TimeKeeper();\n\n        let skinIndex = this._templet.getSkinIndexByName(this._skinName);\n        if (skinIndex != -1)\n            this.showSkinByIndex(skinIndex);\n\n        this._state.addListener({\n            start: (entry: any) => {\n                // console.log(\"started:\", entry);\n            },\n            interrupt: (entry: any) => {\n                // console.log(\"interrupt:\", entry);\n            },\n            end: (entry: any) => {\n                // console.log(\"end:\", entry);\n            },\n            dispose: (entry: any) => {\n                // console.log(\"dispose:\", entry);\n            },\n            complete: (entry: any) => {\n                // console.log(\"complete:\", entry);\n                if (entry.loop) { // 如果多次播放,发送complete事件\n                    this.event(Event.COMPLETE);\n                } else { // 如果只播放一次，就发送stop事件\n                    this._currAniName = null;\n                    this.event(Event.STOPPED);\n                }\n            },\n            event: (entry: any, event: any) => {\n                let eventData = {\n                    audioValue: event.data.audioPath,\n                    audioPath: event.data.audioPath,\n                    floatValue: event.floatValue,\n                    intValue: event.intValue,\n                    name: event.data.name,\n                    stringValue: event.stringValue,\n                    time: event.time * 1000,\n                    balance: event.balance,\n                    volume: event.volume\n                };\n                // console.log(\"event:\", entry, event);\n                this.event(Event.LABEL, eventData);\n                if (this._playAudio && eventData.audioValue) {\n                    let channel = SoundManager.playSound(templet.basePath + eventData.audioValue, 1, Handler.create(this, this._onAniSoundStoped), null, (this._currentPlayTime * 1000 - eventData.time) / 1000);\n                    SoundManager.playbackRate = this._playbackRate;\n                    channel && this._soundChannelArr.push(channel);\n                }\n            },\n        });\n        this._flushExtSkin();\n        this.event(Event.READY);\n\n        if (LayaEnv.isPlaying && this._animationName)\n            this.play(this._animationName, this._loop, true);\n    }\n\n    /**\n     * 播放动画\n     *\n     * @param\tnameOrIndex\t动画名字或者索引\n     * @param\tloop\t\t是否循环播放\n     * @param\tforce\t\tfalse,如果要播的动画跟上一个相同就不生效,true,强制生效\n     * @param\tstart\t\t起始时间\n     * @param\tend\t\t\t结束时间\n     * @param\tfreshSkin\t是否刷新皮肤数据\n     * @param\tplayAudio\t是否播放音频\n     */\n    play(nameOrIndex: any, loop: boolean, force: boolean = true, start: number = 0, end: number = 0, freshSkin: boolean = true, playAudio: boolean = true) {\n        this._playAudio = playAudio;\n        start /= 1000;\n        end /= 1000;\n        let animationName = nameOrIndex;\n        if (start < 0 || end < 0)\n            throw new Error(\"SpineSkeleton: start and end must large than zero.\");\n        if ((end !== 0) && (start > end))\n            throw new Error(\"SpineSkeleton: start must less than end.\");\n\n        if (typeof animationName == \"number\") {\n            animationName = this.getAniNameByIndex(nameOrIndex);\n        }\n\n        if (force || this._pause || this._currAniName != animationName) {\n            this._currAniName = animationName;\n            // 设置执行哪个动画\n            this._state.setAnimation(this.trackIndex, animationName, loop);\n            // 设置起始和结束时间\n            let trackEntry = this._state.getCurrent(this.trackIndex);\n            trackEntry.animationStart = start;\n            if (!!end && end < trackEntry.animationEnd)\n                trackEntry.animationEnd = end;\n\n            let animationDuration = trackEntry.animation.duration;\n            this._duration = animationDuration;\n            this._playStart = start;\n            this._playEnd = end <= animationDuration ? end : animationDuration;\n\n            if (this._pause) {\n                this._pause = false;\n                this.timer.frameLoop(1, this, this._update, null, true);\n            }\n            this._update();\n        }\n    }\n\n    private _update(): void {\n        this._timeKeeper.update();\n        let delta = this._timeKeeper.delta * this._playbackRate;\n        let trackEntry = this._state.getCurrent(this.trackIndex);\n        // 在游戏循环中，update被调用，这样AnimationState就可以跟踪时间\n        this._state.update(delta);\n        // 使用当前动画和事件设置骨架\n        this._state.apply(this._skeleton);\n\n        let animationLast = trackEntry.animationLast;\n        this._currentPlayTime = Math.max(0, animationLast);\n\n        // spine在state.apply中发送事件，开发者可能会在事件中进行destory等操作，导致无法继续执行\n        if (!this._state || !this._skeleton) {\n            return;\n        }\n        // 计算骨骼的世界SRT(world SRT)\n        this._skeleton.updateWorldTransform();\n\n        this.graphics.clear();\n        this._renerer.draw(this._skeleton, this.graphics, -1, -1);\n    }\n\n    private _flushExtSkin() {\n        if (null == this._skeleton) return;\n        let skins = this._externalSkins;\n        if (skins) {\n            for (let i = skins.length - 1; i >= 0; i--) {\n                skins[i].flush();\n            }\n        }\n    }\n    /**\n     * 得到当前动画的数量\n     * @return 当前动画的数量\n     */\n    getAnimNum(): number {\n        return this._templet.skeletonData.animations.length;\n    }\n\n    /**\n     * 得到指定动画的名字\n     * @param\tindex\t动画的索引\n     */\n    getAniNameByIndex(index: number): string {\n        return this._templet.getAniNameByIndex(index);\n    }\n\n    /**\n     * 通过名字得到插槽的引用\n     * @param slotName \n     */\n    getSlotByName(slotName: string) {\n        return this._skeleton.findSlot(slotName)\n    }\n\n    /**\n     * 设置动画播放速率\n     * @param\tvalue\t1为标准速率\n     */\n    playbackRate(value: number): void {\n        this._playbackRate = value;\n    }\n\n    /**\n     * 通过名字显示一套皮肤\n     * @param\tname\t皮肤的名字\n     */\n    showSkinByName(name: string): void {\n        this.showSkinByIndex(this._templet.getSkinIndexByName(name));\n    }\n\n    /**\n     * 通过索引显示一套皮肤\n     * @param\tskinIndex\t皮肤索引\n     */\n    showSkinByIndex(skinIndex: number): void {\n        let newSkine = this._skeleton.data.skins[skinIndex];\n        this._skeleton.setSkin(newSkine);\n        this._skeleton.setSlotsToSetupPose();\n    }\n\n    /**\n     * 停止动画\n     */\n    stop(): void {\n        if (!this._pause) {\n            this._pause = true;\n            this._currAniName = null;\n            this.timer.clear(this, this._update);\n            this._state.update(-this._currentPlayTime);\n            this._currentPlayTime = 0;\n            this.event(Event.STOPPED);\n\n            if (this._soundChannelArr.length > 0) { // 有正在播放的声音\n                this._onAniSoundStoped(true);\n            }\n        }\n    }\n\n    /**\n     * 暂停动画的播放\n     */\n    paused(): void {\n        if (!this._pause) {\n            this._pause = true;\n            this.timer.clear(this, this._update);\n            this.event(Event.PAUSED);\n            if (this._soundChannelArr.length > 0) { // 有正在播放的声音\n                for (let len = this._soundChannelArr.length, i = 0; i < len; i++) {\n                    let channel = this._soundChannelArr[i];\n                    if (!channel.isStopped) {\n                        channel.pause();\n                    }\n\n                }\n            }\n        }\n    }\n\n    /**\n     * 恢复动画的播放\n     */\n    resume(): void {\n        if (this._pause) {\n            this._pause = false;\n            this.timer.frameLoop(1, this, this._update, null, true);\n            if (this._soundChannelArr.length > 0) { // 有正在播放的声音\n                for (let len = this._soundChannelArr.length, i = 0; i < len; i++) {\n                    let channel = this._soundChannelArr[i];\n                    if ((channel as any).audioBuffer) {\n                        channel.resume();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @internal\n     * 清掉播放完成的音频\n     * @param force 是否强制删掉所有的声音channel\n     */\n    private _onAniSoundStoped(force: boolean): void {\n        for (let len = this._soundChannelArr.length, i = 0; i < len; i++) {\n            let channel = this._soundChannelArr[i];\n            if (channel.isStopped || force) {\n                !channel.isStopped && channel.stop();\n                this._soundChannelArr.splice(i, 1);\n                // SoundManager.removeChannel(_channel); // TODO 是否需要? 去掉有什么好处? 是否还需要其他操作?\n                len--; i--;\n            }\n        }\n    }\n\n    private reset() {\n        this._templet._removeReference(1);\n        this._templet = null;\n        this._timeKeeper = null;\n        this._skeleton = null;\n        this._state.clearListeners();\n        this._state = null;\n        this._renerer = null;\n        this._currAniName = null;\n        this._pause = true;\n        this.timer.clear(this, this._update);\n        if (this._soundChannelArr.length > 0)\n            this._onAniSoundStoped(true);\n    }\n\n    /**\n     * 销毁当前动画\n     * @override\n     */\n    destroy(destroyChild: boolean = true): void {\n        super.destroy(destroyChild);\n        if (this._templet)\n            this.reset();\n    }\n\n    // ------------------------------------新增加的接口----------------------------------------------------\n    /**\n     * 添加一个动画\n     * @param nameOrIndex   动画名字或者索引\n     * @param loop          是否循环播放\n     * @param delay         延迟调用，可以为负数\n     */\n    addAnimation(nameOrIndex: any, loop: boolean = false, delay: number = 0) {\n        delay /= 1000;\n        let animationName = nameOrIndex;\n        if (typeof animationName == \"number\") {\n            animationName = this.getAniNameByIndex(animationName);\n        }\n        this._currAniName = animationName;\n        this._state.addAnimation(this.trackIndex, animationName, loop, delay);\n    }\n\n    /**\n     * 设置当动画被改变时，存储混合(交叉淡出)的持续时间\n     * @param fromNameOrIndex \n     * @param toNameOrIndex \n     * @param duration\n     */\n    setMix(fromNameOrIndex: any, toNameOrIndex: any, duration: number) {\n        duration /= 1000;\n        let fromName = fromNameOrIndex;\n        if (typeof fromName == \"number\") {\n            fromName = this.getAniNameByIndex(fromName);\n        }\n        let toName = toNameOrIndex;\n        if (typeof toName == \"number\") {\n            toName = this.getAniNameByIndex(toName);\n        }\n        this._stateData.setMix(fromName, toName, duration);\n    }\n\n    /**\n     * 获取骨骼信息(spine.Bone)\n     * 注意: 获取到的是spine运行时的骨骼信息(spine.Bone)，不适用引擎的方法\n     * @param boneName \n     */\n    getBoneByName(boneName: string) {\n        return this._skeleton.findBone(boneName);\n    }\n\n    /**\n     * 获取Skeleton(spine.Skeleton)\n     */\n    getSkeleton() {\n        return this._skeleton;\n    }\n\n    /**\n     * 替换插槽皮肤\n     * @param slotName \n     * @param attachmentName \n     */\n    setSlotAttachment(slotName: string, attachmentName: string) {\n        this._skeleton.setAttachment(slotName, attachmentName);\n    }\n}","import { IResourceLoader, ILoadTask, Loader } from \"../net/Loader\";\nimport { Utils } from \"../utils/Utils\";\nimport { SpineTemplet } from \"./SpineTemplet\";\n\nclass SpineTempletLoader implements IResourceLoader {\n    load(task: ILoadTask) {\n        let atlasUrl = Utils.replaceFileExtension(task.url, \"atlas\");\n\n        return Promise.all([\n            task.loader.fetch(task.url, task.ext == \"skel\" ? \"arraybuffer\" : \"json\", task.progress.createCallback()),\n            task.loader.fetch(atlasUrl, \"text\", task.progress.createCallback())\n        ]).then(res => {\n            if (!res[0] || !res[1])\n                return null;\n\n            let templet = new SpineTemplet();\n            return templet._parse(res[0], res[1], task.url, task.progress).then(() => templet);\n        });\n    }\n}\n\nLoader.registerLoader([\"skel\"], SpineTempletLoader, Loader.SPINE);","import { ClassUtils } from \"../utils/ClassUtils\";\nimport { ExternalSkin } from \"./ExternalSkin\";\nimport { ExternalSkinItem } from \"./ExternalSkinItem\";\nimport { SpineSkeleton } from \"./SpineSkeleton\";\nimport \"./SpineTempletLoader\";\n\nlet c = ClassUtils.regClass;\n\nc(\"SpineSkeleton\", SpineSkeleton);\nc(\"ExternalSkin\", ExternalSkin);\nc(\"ExternalSkinItem\", ExternalSkinItem);"],"mappings":"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"}