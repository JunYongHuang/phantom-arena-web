{"version":3,"names":["GridSprite","Sprite","constructor","this","relativeX","relativeY","isAloneObject","isHaveAnimation","drawImageNum","_map","initData","map","objectKey","addAniSprite","sprite","aniSpriteArray","push","show","visible","i","length","hide","updatePos","x","_viewPortX","y","_viewPortY","viewPortWidth","viewPortHeight","clearAll","destroy","IMap","TiledMap","TileAniSprite","_tileTextureSet","_aniName","setTileTextureSet","aniName","tileTextureSet","removeAniSprite","MapLayer","_mapData","_tileWidthHalf","_tileHeightHalf","_mapWidthHalf","_mapHeightHalf","_gridSpriteArray","_objDic","_dataDic","_tempMapPos","Point","layerName","init","layerData","data","height","width","tTileW","tileWidth","tTileH","tileHeight","name","_properties","properties","alpha","opacity","type","tObjectData","tObjWidth","tObjHeight","tArray","objects","tSprite","getSprite","gid","orientation","ORIENTATION_ISOMETRIC","getScreenPositionByTilePos","TEMP","pivot","rotation","viewPortX","viewPortY","ORIENTATION_STAGGERED","ORIENTATION_ORTHOGONAL","ORIENTATION_HEXAGONAL","addChild","getObjectByName","objName","getObjectDataByName","getLayerProperties","getTileData","tileX","tileY","numRowsTile","numColumnsTile","tIndex","tMapData","screenPos","Math","floor","tTileHeight","gridWidth","gridHeight","scale","getTileDataByScreenPos","screenX","screenY","tData","getTilePositionByScreenPos","result","tV","tU","tDirX","rx","ry","abs","getDrawSprite","gridX","gridY","updateGridPos","drawTileTexture","gridSprite","tTileTexSet","getTexture","tX","tY","texture","isAnimation","tAnimationSprite","toString","graphics","drawImage","offX","offY","p","tarLayer","TileTexSet","textureArray","durationTimeArray","animationTotalTime","_spriteNum","_aniDic","_frameIndex","_time","_interval","_preFrameTime","ILaya","timer","frameLoop","animate","Browser","now","tTileTextureSet","drawTexture","tNow","tTime","tileTextSet","clear","_name","showDebugInfo","tInfo","_tileTexSetArr","_texArray","_x","_y","_width","_height","_mapW","_mapH","_mapTileW","_mapTileH","_rect","Rectangle","_paddingRect","_mapSprite","_layerArray","_renderLayerArray","_gridArray","_showGridKey","_totalGridNum","_gridW","_gridH","_gridWidth","_gridHeight","_tileSetArray","_currTileSet","_completeHandler","_mapRect","GRect","_mapLastRect","_index","_animationDic","_tileProperties","_tileProperties2","_orientation","_renderOrder","_colorArray","_scale","_pivotScaleX","_pivotScaleY","_centerX","_centerY","_viewPortWidth","_viewPortHeight","_enableLinear","_limitRange","autoCache","autoCacheType","enableMergeLayer","removeCoveredTile","showGridTextureCount","antiCrack","cacheAllAfterInit","_texutreStartDic","createMap","mapName","viewRect","completeHandler","viewRectPadding","gridSize","enableLinear","limitRange","copyFrom","setTo","lastIndexOf","_resPath","substr","_pathArray","split","loader","fetch","then","content","onJsonComplete","tJsonData","stage","_jsonData","renderorder","tilewidth","tileheight","top","bottom","left","right","tileset","tTileSet","tilesets","TileSet","ignore","tileproperties","addTileProperties","tTiles","tiles","tAnimation","animation","tAniData","TileMapAniData","image","j","tAnimationItem","mAniIdArray","tileid","mDurationTimeArray","duration","shift","tPath","mergePath","load","tex","onTextureComplete","resPath","relativePath","tResultPath","tImageArray","tParentPathNum","tSrcNum","console","log","tTexture","bitmap","filterMode","FilterMode","tTileTextureW","tTileTextureH","tImageWidth","imagewidth","tImageHeight","imageheight","firstgid","tTileWNum","margin","spacing","tTileHNum","titleoffsetX","titleoffsetY","Texture","createFromTexture","adptTexture","initMap","pX","uv","pX1","pY","pY1","dW","dH","Tex","n","gStart","parseInt","ceil","tGridArray","tLayerTarLayerName","preLayerTarName","preLayer","tLayerArray","layers","isFirst","tLayerLoop","tLayerData","tMapLayer","adptTiledMapData","cacheAllGrid","moveViewPort","run","tileDataDic","key","getTileUserData","id","sign","defaultV","tDatas","noNeeds","removeCoverd","collectCovers","datas","len","layer","tTileData","index","getMapProperties","getTileProperties","tGridSprite","size","setViewPortPivotByScale","scaleX","scaleY","updateViewPort","moveX","moveY","changeViewPort","changeViewPortBySize","rect","posChanged","preValue","tPaddingRect","clipViewPort","tSub","tAdd","hideGrid","min","showGrid","max","tTempArray","getGridArray","tempArr","cacheGridsArray","arr","canvas","tGrid","_tempCanvas","HTMLCanvas","tx","context","getContext","asBitmap","render","tLeft","tRight","tTop","tBottom","tGridWidth","tGridHeight","tLeft1","tRight1","tTop1","tBottom1","tHeight","tTGridSprite","tDrawMapLayer","tLayer","z","tColorStr","random","tHalfTileHeight","tHalfTileWidth","tHalfMapWidth","tMapH","zOrder","tIndexX","tIndexY","tIndexValue","RENDERORDER_RIGHTDOWN","RENDERORDER_RIGHTUP","RENDERORDER_LEFTDOWN","RENDERORDER_LEFTUP","autoSize","cacheAs","drawRect","fillText","getLayerObject","objectName","tDic","numColumnsGrid","numRowsGrid","renderOrder","mapSprite","getLayerByName","getLayerByIndex","mTileTexSetArr","tTileoffset","tileoffset"],"sources":["../../src/layaAir/laya/map/GridSprite.ts","../../src/layaAir/laya/map/IMap.ts","../../src/layaAir/laya/map/TileAniSprite.ts","../../src/layaAir/laya/map/MapLayer.ts","../../src/layaAir/laya/map/TileTexSet.ts","../../src/layaAir/laya/map/TiledMap.ts"],"sourcesContent":["import { TiledMap } from \"./TiledMap\";\nimport { TileAniSprite } from \"./TileAniSprite\";\nimport { Sprite } from \"../display/Sprite\";\n\n\n\n/**\n * 地图的每层都会分块渲染处理\n * 本类就是地图的块数据\n * @author ...\n */\nexport class GridSprite extends Sprite {\n\n    /**相对于地图X轴的坐标*/\n    relativeX: number = 0;\n    /**相对于地图Y轴的坐标*/\n    relativeY: number = 0;\n    /**是否用于对象层的独立物件*/\n    isAloneObject: boolean = false;\n    /**当前GRID中是否有动画*/\n    isHaveAnimation: boolean = false;\n    /**当前GRID包含的动画*/\n    aniSpriteArray: any[];\n    /**当前GRID包含多少个TILE(包含动画)*/\n    drawImageNum: number = 0;\n\n    private _map: TiledMap = null;//当前地图对象的引用\n\n    /**\n     * 传入必要的参数，用于裁剪，跟确认此对象类型\n     * @param\tmap\t把地图的引用传进来，参与一些裁剪计算\n     * @param\tobjectKey true:表示当前GridSprite是个活动对象，可以控制，false:地图层的组成块\n     */\n    initData(map: TiledMap, objectKey: boolean = false): void {\n        this._map = map;\n        this.isAloneObject = objectKey;\n    }\n\n    /**\n     * 把一个动画对象绑定到当前GridSprite\n     * @param\tsprite 动画的显示对象\n     */\n    addAniSprite(sprite: TileAniSprite): void {\n        if (this.aniSpriteArray == null) {\n            this.aniSpriteArray = [];\n        }\n        this.aniSpriteArray.push(sprite);\n    }\n\n    /**\n     * 显示当前GridSprite，并把上面的动画全部显示\n     */\n    show(): void {\n        if (!this.visible) {\n            this.visible = true;\n            if (this.aniSpriteArray == null) {\n                return;\n            }\n            var tAniSprite: TileAniSprite;\n            for (var i: number = 0; i < this.aniSpriteArray.length; i++) {\n                tAniSprite = this.aniSpriteArray[i];\n                tAniSprite.show();\n            }\n        }\n    }\n\n    /**\n     * 隐藏当前GridSprite，并把上面绑定的动画全部移除\n     */\n    hide(): void {\n        if (this.visible) {\n            this.visible = false;\n            if (this.aniSpriteArray == null) {\n                return;\n            }\n            var tAniSprite: TileAniSprite;\n            for (var i: number = 0; i < this.aniSpriteArray.length; i++) {\n                tAniSprite = this.aniSpriteArray[i];\n                tAniSprite.hide();\n            }\n        }\n    }\n\n    /**\n     * 刷新坐标，当我们自己控制一个GridSprite移动时，需要调用此函数，手动刷新\n     */\n    updatePos(): void {\n        if (this.isAloneObject) {\n            if (this._map) {\n                this.x = this.relativeX - this._map._viewPortX;\n                this.y = this.relativeY - this._map._viewPortY;\n            }\n            if (this.x < 0 || this.x > this._map.viewPortWidth || this.y < 0 || this.y > this._map.viewPortHeight) {\n                this.hide();\n            } else {\n                this.show();\n            }\n        } else {\n            if (this._map) {\n                this.x = this.relativeX - this._map._viewPortX;\n                this.y = this.relativeY - this._map._viewPortY;\n            }\n        }\n    }\n\n    /**\n     * 重置当前对象的所有属性\n     */\n    clearAll(): void {\n        if (this._map) {\n            this._map = null;\n        }\n        this.visible = false;\n\n        var tAniSprite: TileAniSprite;\n\n        if (this.aniSpriteArray != null) {\n            for (var i: number = 0; i < this.aniSpriteArray.length; i++) {\n                tAniSprite = this.aniSpriteArray[i];\n                tAniSprite.clearAll();\n            }\n        }\n\n        this.destroy();\n        this.relativeX = 0;\n        this.relativeY = 0;\n        this.isHaveAnimation = false;\n        this.aniSpriteArray = null;\n        this.drawImageNum = 0;\n    }\n\n}\n\n\n","import { TiledMap } from \"./TiledMap\";\n/**\n * @internal\n */\nexport class IMap{\n    static TiledMap:typeof TiledMap=null;\n}","import { TileTexSet } from \"./TileTexSet\";\nimport { Sprite } from \"../display/Sprite\";\n\n/**\n * TildMap的动画显示对象（一个动画（TileTexSet），可以绑定多个动画显示对象（TileAniSprite））\n * @author ...\n */\nexport class TileAniSprite extends Sprite {\n\n    private _tileTextureSet: TileTexSet = null;//动画的引用\n    private _aniName: string = null;//当前动画显示对象的名字，名字唯一\n\n    /**\n     * 确定当前显示对象的名称以及属于哪个动画\n     * @param\taniName\t当前动画显示对象的名字，名字唯一\n     * @param\ttileTextureSet 当前显示对象属于哪个动画（一个动画，可以绑定多个同类显示对象）\n     */\n    setTileTextureSet(aniName: string, tileTextureSet: TileTexSet): void {\n        this._aniName = aniName;\n        this._tileTextureSet = tileTextureSet;\n        tileTextureSet.addAniSprite(this._aniName, this);\n    }\n\n    /**\n     * 把当前动画加入到对应的动画刷新列表中\n     */\n    show(): void {\n        this._tileTextureSet.addAniSprite(this._aniName, this);\n    }\n\n    /**\n     * 把当前动画从对应的动画刷新列表中移除\n     */\n    hide(): void {\n        this._tileTextureSet.removeAniSprite(this._aniName);\n    }\n\n    /**\n     * 清理\n     */\n    clearAll(): void {\n        this._tileTextureSet.removeAniSprite(this._aniName);\n        this.destroy();\n        this._tileTextureSet = null;\n        this._aniName = null;\n    }\n}\n\n\n","import { TileTexSet } from \"./TileTexSet\";\nimport { TileAniSprite } from \"./TileAniSprite\";\nimport { GridSprite } from \"./GridSprite\";\nimport { IMap } from \"./IMap\";\nimport { TiledMap } from \"./TiledMap\";\nimport { Sprite } from \"../display/Sprite\";\nimport { Point } from \"../maths/Point\";\nimport { Texture } from \"../resource/Texture\";\n\n\n/**\n * 地图支持多层渲染（例如，地表层，植被层，建筑层等）\n * 本类就是层级类\n * @author ...\n */\nexport class MapLayer extends Sprite {\n\n    private _map: TiledMap;\n    /**@internal */\n    _mapData: any[] = null;\n\n    private _tileWidthHalf: number = 0;\n    private _tileHeightHalf: number = 0;\n\n    private _mapWidthHalf: number = 0;\n    private _mapHeightHalf: number = 0;\n\n    /**\n     * @internal\n     */\n    _gridSpriteArray: any[] = [];\n    private _objDic: any = null;//用来做字典，方便查询\n    private _dataDic: any = null;\n\n    private _tempMapPos: Point = new Point();//临时变量\n    private _properties: any;\n\n    /**被合到的层*/\n    tarLayer: MapLayer;\n\n    /**当前Layer的名称*/\n    layerName: string = null;\n\n    /**\n     * 解析LAYER数据，以及初始化一些数据\n     * @param\tlayerData 地图数据中，layer数据的引用\n     * @param\tmap 地图的引用\n     */\n    init(layerData: any, map: TiledMap): void {\n        this._map = map;\n        this._mapData = layerData.data;\n        //地图宽和高（单位:格子）\n        var tHeight: number = layerData.height;\n        var tWidth: number = layerData.width;\n\n        var tTileW: number = map.tileWidth;\n        var tTileH: number = map.tileHeight;\n\n        this.layerName = layerData.name;\n        this._properties = layerData.properties;\n        this.alpha = layerData.opacity;\n\n        this._tileWidthHalf = tTileW / 2;\n        this._tileHeightHalf = tTileH / 2;\n\n        //减一半的格子，加到这，是因为，下面计算坐标的时候，可以减少计算量\n        this._mapWidthHalf = this._map.width / 2 - this._tileWidthHalf;\n        this._mapHeightHalf = this._map.height / 2;\n        //这里要特别注意，有时间去查查JS源代码支持的所有类型\n        switch (layerData.type) {\n            case \"tilelayer\":\n                break;\n            case \"objectgroup\":\n                //这里的东西必需要一开始就创建，所以要用物品的动态管理做下\n                var tObjectGid: number = 0;\n                var tArray: any[] = layerData.objects;\n                if (tArray.length > 0) {\n                    this._objDic = {};\n                    this._dataDic = {};\n                }\n                var tObjectData: any;\n                var tObjWidth: number;\n                var tObjHeight: number;\n                for (var i: number = 0; i < tArray.length; i++) {\n                    tObjectData = tArray[i];\n                    this._dataDic[tObjectData.name] = tObjectData;\n                    //这里要看具体需求，看是不是要开放\n                    if (tObjectData.visible == true) {\n                        tObjWidth = tObjectData.width;\n                        tObjHeight = tObjectData.height;\n                        var tSprite: GridSprite = map.getSprite(tObjectData.gid, tObjWidth, tObjHeight);\n                        if (tSprite != null) {\n                            switch (this._map.orientation) {\n                                case IMap.TiledMap.ORIENTATION_ISOMETRIC:\n                                    this.getScreenPositionByTilePos(tObjectData.x / tTileH, tObjectData.y / tTileH, Point.TEMP);\n                                    tSprite.pivot(tObjWidth / 2, tObjHeight / 2);\n                                    tSprite.rotation = tObjectData.rotation;\n                                    tSprite.x = tSprite.relativeX = Point.TEMP.x + this._map.viewPortX;\n                                    tSprite.y = tSprite.relativeY = Point.TEMP.y + this._map.viewPortY - tObjHeight / 2;\n                                    break;\n                                case IMap.TiledMap.ORIENTATION_STAGGERED://对象旋转后坐标计算的不对。。\n                                    tSprite.pivot(tObjWidth / 2, tObjHeight / 2);\n                                    tSprite.rotation = tObjectData.rotation;\n                                    tSprite.x = tSprite.relativeX = tObjectData.x + tObjWidth / 2;\n                                    tSprite.y = tSprite.relativeY = tObjectData.y - tObjHeight / 2;\n                                    break;\n                                case IMap.TiledMap.ORIENTATION_ORTHOGONAL:\n                                    tSprite.pivot(tObjWidth / 2, tObjHeight / 2);\n                                    tSprite.rotation = tObjectData.rotation;\n                                    tSprite.x = tSprite.relativeX = tObjectData.x + tObjWidth / 2;\n                                    tSprite.y = tSprite.relativeY = tObjectData.y - tObjHeight / 2;\n                                    break;\n                                case IMap.TiledMap.ORIENTATION_HEXAGONAL://待测试\n                                    tSprite.x = tSprite.relativeX = tObjectData.x;\n                                    tSprite.y = tSprite.relativeY = tObjectData.y;\n                                    break;\n                            }\n                            this.addChild(tSprite);\n                            this._gridSpriteArray.push(tSprite);\n                            this._objDic[tObjectData.name] = tSprite;\n                        }\n                    }\n                }\n                break;\n        }\n    }\n\n    /******************************************对外接口*********************************************/\n    /**\n     * 通过名字获取控制对象，如果找不到返回为null\n     * @param\tobjName 所要获取对象的名字\n     * @return\n     */\n    getObjectByName(objName: string): GridSprite {\n        if (this._objDic) {\n            return this._objDic[objName];\n        }\n        return null;\n    }\n\n\n    /**\n     * 通过名字获取数据，如果找不到返回为null\n     * @param\tobjName 所要获取对象的名字\n     * @return\n     */\n    getObjectDataByName(objName: string): any {\n        if (this._dataDic) {\n            return this._dataDic[objName];\n        }\n        return null;\n    }\n\n    /**\n     * 得到地图层的自定义属性\n     * @param\tname\n     * @return\n     */\n    getLayerProperties(name: string): any {\n        if (this._properties) {\n            return this._properties[name];\n        }\n        return null;\n    }\n\n    /**\n     * 得到指定格子的数据\n     * @param\ttileX 格子坐标X\n     * @param\ttileY 格子坐标Y\n     * @return\n     */\n    getTileData(tileX: number, tileY: number): number {\n        if (tileY >= 0 && tileY < this._map.numRowsTile && tileX >= 0 && tileX < this._map.numColumnsTile) {\n            var tIndex: number = tileY * this._map.numColumnsTile + tileX;\n            var tMapData: any[] = this._mapData;\n            if (tMapData != null && tIndex < tMapData.length) {\n                return tMapData[tIndex];\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * 通过地图坐标得到屏幕坐标\n     * @param\ttileX 格子坐标X\n     * @param\ttileY 格子坐标Y\n     * @param\tscreenPos 把计算好的屏幕坐标数据，放到此对象中\n     */\n    getScreenPositionByTilePos(tileX: number, tileY: number, screenPos: Point = null): void {\n        if (screenPos) {\n            switch (this._map.orientation) {\n                case IMap.TiledMap.ORIENTATION_ISOMETRIC:\n                    screenPos.x = this._map.width / 2 - (tileY - tileX) * this._tileWidthHalf;\n                    screenPos.y = (tileY + tileX) * this._tileHeightHalf;\n                    break;\n                case IMap.TiledMap.ORIENTATION_STAGGERED:\n                    tileX = Math.floor(tileX);\n                    tileY = Math.floor(tileY);\n                    screenPos.x = tileX * this._map.tileWidth + (tileY & 1) * this._tileWidthHalf;\n                    screenPos.y = tileY * this._tileHeightHalf;\n                    break;\n                case IMap.TiledMap.ORIENTATION_ORTHOGONAL:\n                    screenPos.x = tileX * this._map.tileWidth;\n                    screenPos.y = tileY * this._map.tileHeight;\n                    break;\n                case IMap.TiledMap.ORIENTATION_HEXAGONAL:\n                    tileX = Math.floor(tileX);\n                    tileY = Math.floor(tileY);\n                    var tTileHeight: number = this._map.tileHeight * 2 / 3;\n                    screenPos.x = (tileX * this._map.tileWidth + tileY % 2 * this._tileWidthHalf) % this._map.gridWidth;\n                    screenPos.y = (tileY * tTileHeight) % this._map.gridHeight;\n                    break;\n            }\n            //地图坐标转换成屏幕坐标\n            screenPos.x = (screenPos.x + this._map.viewPortX) * this._map.scale;\n            screenPos.y = (screenPos.y + this._map.viewPortY) * this._map.scale;\n        }\n    }\n\n    /**\n     * 通过屏幕坐标来获取选中格子的数据\n     * @param\tscreenX 屏幕坐标x\n     * @param\tscreenY 屏幕坐标y\n     * @return\n     */\n    getTileDataByScreenPos(screenX: number, screenY: number): number {\n        var tData: number = 0;\n        if (this.getTilePositionByScreenPos(screenX, screenY, this._tempMapPos)) {\n            tData = this.getTileData(Math.floor(this._tempMapPos.x), Math.floor(this._tempMapPos.y));\n        }\n        return tData;\n    }\n\n    /**\n     * 通过屏幕坐标来获取选中格子的索引\n     * @param\tscreenX 屏幕坐标x\n     * @param\tscreenY 屏幕坐标y\n     * @param\tresult 把计算好的格子坐标，放到此对象中\n     * @return\n     */\n    getTilePositionByScreenPos(screenX: number, screenY: number, result: Point = null): boolean {\n        //转换成地图坐标\n        screenX = screenX / this._map.scale - this._map.viewPortX;\n        screenY = screenY / this._map.scale - this._map.viewPortY;\n        var tTileW: number = this._map.tileWidth;\n        var tTileH: number = this._map.tileHeight;\n\n        var tV: number = 0;\n        var tU: number = 0;\n        switch (this._map.orientation) {\n            case IMap.TiledMap.ORIENTATION_ISOMETRIC://45度角\n                var tDirX: number = screenX - this._map.width / 2;\n                var tDirY: number = screenY;\n                tV = -(tDirX / tTileW - tDirY / tTileH);\n                tU = tDirX / tTileW + tDirY / tTileH;\n                if (result) {\n                    result.x = tU;\n                    result.y = tV;\n                }\n                return true;\n                break;\n            case IMap.TiledMap.ORIENTATION_STAGGERED://45度交错地图\n                if (result) {\n                    var cx: number, cy: number, rx: number, ry: number;\n                    cx = Math.floor(screenX / tTileW) * tTileW + tTileW / 2;        //计算出当前X所在的以tileWidth为宽的矩形的中心的X坐标\n                    cy = Math.floor(screenY / tTileH) * tTileH + tTileH / 2;//计算出当前Y所在的以tileHeight为高的矩形的中心的Y坐标\n\n                    rx = (screenX - cx) * tTileH / 2;\n                    ry = (screenY - cy) * tTileW / 2;\n\n                    if (Math.abs(rx) + Math.abs(ry) <= tTileW * tTileH / 4) {\n                        tU = Math.floor(screenX / tTileW);\n                        tV = Math.floor(screenY / tTileH) * 2;\n                    } else {\n                        screenX = screenX - tTileW / 2;\n                        tU = Math.floor(screenX / tTileW) + 1;\n                        screenY = screenY - tTileH / 2;\n                        tV = Math.floor(screenY / tTileH) * 2 + 1;\n                    }\n                    result.x = tU - (tV & 1);\n                    result.y = tV;\n                }\n                return true;\n                break;\n            case IMap.TiledMap.ORIENTATION_ORTHOGONAL://直角\n                tU = screenX / tTileW;\n                tV = screenY / tTileH;\n                if (result) {\n                    result.x = tU;\n                    result.y = tV;\n                }\n                return true;\n                break;\n            case IMap.TiledMap.ORIENTATION_HEXAGONAL://六边形\n                var tTileHeight: number = tTileH * 2 / 3;\n                tV = screenY / tTileHeight;\n                tU = (screenX - tV % 2 * this._tileWidthHalf) / tTileW;\n                if (result) {\n                    result.x = tU;\n                    result.y = tV;\n                }\n                break;\n        }\n        return false;\n    }\n\n    /***********************************************************************************************/\n    /**\n     * 得到一个GridSprite\n     * @param\tgridX 当前Grid的X轴索引\n     * @param\tgridY 当前Grid的Y轴索引\n     * @return  一个GridSprite对象\n     */\n    getDrawSprite(gridX: number, gridY: number): GridSprite {\n        var tSprite: GridSprite = new GridSprite();\n        tSprite.relativeX = gridX * this._map.gridWidth;\n        tSprite.relativeY = gridY * this._map.gridHeight;\n        tSprite.initData(this._map);\n        this._gridSpriteArray.push(tSprite);\n        return tSprite;\n    }\n\n    /**\n     * 更新此层中块的坐标\n     * 手动刷新的目的是，保持层级的宽和高保持最小，加快渲染\n     */\n    updateGridPos(): void {\n        var tSprite: GridSprite;\n        for (var i: number = 0; i < this._gridSpriteArray.length; i++) {\n            tSprite = this._gridSpriteArray[i];\n            if ((tSprite.visible || tSprite.isAloneObject) && tSprite.drawImageNum > 0) {\n                tSprite.updatePos();\n            }\n        }\n    }\n\n    /**\n     * @private\n     * 把tile画到指定的显示对象上\n     * @param\tgridSprite 被指定显示的目标\n     * @param\ttileX 格子的X轴坐标\n     * @param\ttileY 格子的Y轴坐标\n     * @return\n     */\n    drawTileTexture(gridSprite: GridSprite, tileX: number, tileY: number): boolean {\n        if (tileY >= 0 && tileY < this._map.numRowsTile && tileX >= 0 && tileX < this._map.numColumnsTile) {\n            var tIndex: number = tileY * this._map.numColumnsTile + tileX;\n            var tMapData: any[] = this._mapData;\n            if (tMapData != null && tIndex < tMapData.length) {\n                if (tMapData[tIndex] != 0) {\n                    var tTileTexSet: TileTexSet = this._map.getTexture(tMapData[tIndex]);\n                    if (tTileTexSet) {\n                        var tX: number = 0;\n                        var tY: number = 0;\n                        var tTexture: Texture = tTileTexSet.texture;\n                        switch (this._map.orientation) {\n                            case IMap.TiledMap.ORIENTATION_STAGGERED://45度交错地图\n                                tX = tileX * this._map.tileWidth % this._map.gridWidth + (tileY & 1) * this._tileWidthHalf;\n                                tY = tileY * this._tileHeightHalf % this._map.gridHeight;\n                                break;\n                            case IMap.TiledMap.ORIENTATION_ORTHOGONAL://直角\n                                tX = tileX * this._map.tileWidth % this._map.gridWidth;\n                                tY = tileY * this._map.tileHeight % this._map.gridHeight;\n                                break;\n                            case IMap.TiledMap.ORIENTATION_ISOMETRIC://45度角\n                                tX = (this._mapWidthHalf + (tileX - tileY) * this._tileWidthHalf) % this._map.gridWidth;\n                                tY = ((tileX + tileY) * this._tileHeightHalf) % this._map.gridHeight;\n                                break;\n                            case IMap.TiledMap.ORIENTATION_HEXAGONAL://六边形\n                                var tTileHeight: number = this._map.tileHeight * 2 / 3;\n                                tX = (tileX * this._map.tileWidth + tileY % 2 * this._tileWidthHalf) % this._map.gridWidth;\n                                tY = (tileY * tTileHeight) % this._map.gridHeight;\n                                break;\n                        }\n                        if (tTileTexSet.isAnimation) {\n                            var tAnimationSprite: TileAniSprite = new TileAniSprite();\n                            tAnimationSprite.x = tX;\n                            tAnimationSprite.y = tY;\n                            tAnimationSprite.setTileTextureSet(tIndex.toString(), tTileTexSet);\n                            gridSprite.addAniSprite(tAnimationSprite);\n                            gridSprite.addChild(tAnimationSprite);\n                            gridSprite.isHaveAnimation = true;\n                        } else {\n                            //gridSprite.graphics.drawImage(tTileTexSet.texture, tX + tTileTexSet.offX, tY + tTileTexSet.offY, tTexture.width, tTexture.height);\n                            gridSprite.graphics.drawImage(tTileTexSet.texture, tX + tTileTexSet.offX, tY + tTileTexSet.offY);\n                        }\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @private\n     * 清理当前对象\n     */\n    clearAll(): void {\n        this._map = null;\n        this._mapData = null;\n        this._tileWidthHalf = 0;\n        this._tileHeightHalf = 0;\n        this._mapWidthHalf = 0;\n        this._mapHeightHalf = 0;\n        this.layerName = null;\n        var i: number = 0;\n        if (this._objDic) {\n            for (var p in this._objDic) {\n                delete this._objDic[p];\n            }\n            this._objDic = null;\n        }\n        if (this._dataDic) {\n            for (p in this._dataDic) {\n                delete this._dataDic[p];\n            }\n            this._dataDic = null;\n        }\n        var tGridSprite: GridSprite;\n        for (i = 0; i < this._gridSpriteArray.length; i++) {\n            tGridSprite = this._gridSpriteArray[i];\n            tGridSprite.clearAll();\n        }\n        this._properties = null;\n        this._tempMapPos = null;\n        this.tarLayer = null;\n    }\n}\n\n","import { TileAniSprite } from \"./TileAniSprite\";\nimport { Texture } from \"../resource/Texture\";\nimport { ILaya } from \"../../ILaya\";\n\n\n\n/**\n * 此类是子纹理类，也包括同类动画的管理\n * TiledMap会把纹理分割成无数子纹理，也可以把其中的某块子纹理替换成一个动画序列\n * 本类的实现就是如果发现子纹理被替换成一个动画序列，animationKey会被设为true\n * 即animationKey为true,就使用TileAniSprite来做显示，把动画序列根据时间画到TileAniSprite上\n * @author ...\n */\nexport class TileTexSet {\n\n    /**唯一标识*/\n    gid: number = -1;\n    /**子纹理的引用*/\n    texture: Texture;\n    /**纹理显示时的坐标偏移X*/\n    offX: number = 0;\n    /**纹理显示时的坐标偏移Y*/\n    offY: number = 0;\n\n    //下面是动画支持需要的\n    /**当前要播放动画的纹理序列*/\n    textureArray: any[] = null;\n    /** 当前动画每帧的时间间隔*/\n    durationTimeArray: any[] = null;\n    /** 动画播放的总时间 */\n    animationTotalTime: number = 0;\n    /**true表示当前纹理，是一组动画，false表示当前只有一个纹理*/\n    isAnimation: boolean = false;\n\n    private _spriteNum: number = 0;\t\t\t\t//当前动画有多少个显示对象\n    private _aniDic: any = null;\t\t\t//通过显示对象的唯一名字，去保存显示显示对象\n    private _frameIndex: number = 0;\t\t\t//当前动画播放到第几帧\n\n    private _time: number = 0;\t\t\t\t\t//距离上次动画刷新，过了多少长时间\n    private _interval: number = 0;\t\t\t\t//每帧刷新的时间间隔\n    private _preFrameTime: number = 0;\t\t\t//上一帧刷新的时间戳\n\n    /**\n     * 加入一个动画显示对象到此动画中\n     * @param\taniName\t//显示对象的名字\n     * @param\tsprite\t//显示对象\n     */\n    addAniSprite(aniName: string, sprite: TileAniSprite): void {\n        if (this.animationTotalTime == 0) {\n            return;\n        }\n        if (this._aniDic == null) {\n            this._aniDic = {};\n        }\n        if (this._spriteNum == 0) {\n            //每3帧刷新一下吧，每帧刷新可能太耗了\n            ILaya.timer.frameLoop(3, this, this.animate);\n            this._preFrameTime = ILaya.Browser.now();\n            this._frameIndex = 0;\n            this._time = 0;\n            this._interval = 0;\n        }\n        this._spriteNum++;\n        this._aniDic[aniName] = sprite;\n        if (this.textureArray && this._frameIndex < this.textureArray.length) {\n            var tTileTextureSet: TileTexSet = this.textureArray[this._frameIndex];\n            this.drawTexture(sprite, tTileTextureSet);\n        }\n    }\n\n    /**\n     * 把动画画到所有注册的SPRITE上\n     */\n    private animate(): void {\n        if (this.textureArray && this.textureArray.length > 0 && this.durationTimeArray && this.durationTimeArray.length > 0) {\n            var tNow: number = ILaya.Browser.now();\n            this._interval = tNow - this._preFrameTime;\n            this._preFrameTime = tNow;\n            if (this._interval > this.animationTotalTime) {\n                this._interval = this._interval % this.animationTotalTime;\n            }\n            this._time += this._interval;\n            var tTime: number = this.durationTimeArray[this._frameIndex];\n            while (this._time > tTime) {\n                this._time -= tTime;\n                this._frameIndex++;\n                if (this._frameIndex >= this.durationTimeArray.length || this._frameIndex >= this.textureArray.length) {\n                    this._frameIndex = 0;\n                }\n                var tTileTextureSet: TileTexSet = this.textureArray[this._frameIndex];\n                var tSprite: TileAniSprite;\n                for (var p in this._aniDic) {\n                    tSprite = this._aniDic[p];\n                    this.drawTexture(tSprite, tTileTextureSet);\n                }\n                tTime = this.durationTimeArray[this._frameIndex];\n            }\n        }\n    }\n\n    private drawTexture(sprite: TileAniSprite, tileTextSet: TileTexSet): void {\n        sprite.graphics.clear(true);\n        //sprite.graphics.drawImage(tileTextSet.texture, tileTextSet.offX, tileTextSet.offY, tileTextSet.texture.width, tileTextSet.texture.height);\n        sprite.graphics.drawImage(tileTextSet.texture, tileTextSet.offX, tileTextSet.offY);\n    }\n\n    /**\n     * 移除不需要更新的SPRITE\n     * @param\t_name\n     */\n    removeAniSprite(_name: string): void {\n        if (this._aniDic && this._aniDic[_name]) {\n            delete this._aniDic[_name];\n            this._spriteNum--\n            if (this._spriteNum == 0) {\n                ILaya.timer.clear(this, this.animate);\n            }\n        }\n    }\n\n    /**\n     * 显示当前动画的使用情况\n     */\n    showDebugInfo(): string {\n        var tInfo: string = null;\n        if (this._spriteNum > 0) {\n            tInfo = \"TileTextureSet::gid:\" + this.gid.toString() + \" 动画数:\" + this._spriteNum.toString();\n        }\n        return tInfo;\n    }\n\n    /**\n     * 清理\n     */\n    clearAll(): void {\n        this.gid = -1;//唯一标识\n        if (this.texture) {\n            this.texture.destroy();\n            this.texture = null;\n        }\n        this.offX = 0;\n        this.offY = 0;\n\n        this.textureArray = null;\n        this.durationTimeArray = null;\n        this.isAnimation = false;\n        this._spriteNum = 0;\n        this._aniDic = null;\n        this._frameIndex = 0;\n        this._preFrameTime = 0;\n        this._time = 0;\n        this._interval = 0;\n    }\n\n}\n\n\n","import { MapLayer } from \"./MapLayer\"\nimport { TileTexSet } from \"./TileTexSet\";\nimport { GridSprite } from \"./GridSprite\";\nimport { TileAniSprite } from \"./TileAniSprite\";\nimport { IMap } from \"./IMap\";\nimport { Rectangle } from \"../maths/Rectangle\";\nimport { Sprite } from \"../display/Sprite\";\nimport { Handler } from \"../utils/Handler\";\nimport { ILaya } from \"../../ILaya\";\nimport { Texture } from \"../resource/Texture\";\nimport { HTMLCanvas } from \"../resource/HTMLCanvas\";\nimport { Point } from \"../maths/Point\";\nimport { Context } from \"../resource/Context\";\nimport { FilterMode } from \"../RenderEngine/RenderEnum/FilterMode\";\n\n/**\n * tiledMap是整个地图的核心\n * 地图以层级来划分地图（例如：地表层，植被层，建筑层）\n * 每层又以分块（GridSprite)来处理显示对象，只显示在视口区域的区\n * 每块又包括N*N个格子（tile)\n * 格子类型又分为动画格子跟图片格子两种\n * @author ...\n */\nexport class TiledMap {\n    //地图支持的类型(目前支持四边形地图，菱形地图，六边形地图)\n    /**四边形地图*/\n    static ORIENTATION_ORTHOGONAL: string = \"orthogonal\";\n    /**菱形地图*/\n    static ORIENTATION_ISOMETRIC: string = \"isometric\";\n    /**45度交错地图*/\n    static ORIENTATION_STAGGERED: string = \"staggered\";\n    /**六边形地图*/\n    static ORIENTATION_HEXAGONAL: string = \"hexagonal\";\n    //地图格子（tile）的渲染顺序\n    /**地图格子从左上角开始渲染*/\n    static RENDERORDER_RIGHTDOWN: string = \"right-down\";\n    /**地图格子从左下角开始渲染*/\n    static RENDERORDER_RIGHTUP: string = \"right-up\";\n    /**地图格子从右上角开始渲染*/\n    static RENDERORDER_LEFTDOWN: string = \"left-down\";\n    /**地图格子右下角开始渲染*/\n    static RENDERORDER_LEFTUP: string = \"left-up\";\n\n    //json数据\n    private _jsonData: any;\n    //存放地图中用到的所有子纹理数据\n    private _tileTexSetArr: any[] = [];\n    //主纹理数据，主要在释放纹理资源时使用\n    private _texArray: any[] = [];\n    //地图信息中的一些基本数据\n    private _x: number = 0; //地图的坐标\n    private _y: number = 0;\n    //_width = _mapTileW * _mapW\n    //_height = _mapTileH * _mapH\n    private _width: number = 0; //地图的宽度\n    private _height: number = 0; //地图的高度\n    private _mapW: number = 0; //地图的横向格子数\n    private _mapH: number = 0; //地图的竖向格子数\n    private _mapTileW: number = 0; //tile的宽度\n    private _mapTileH: number = 0; //tile的高度\n\n    //用来存放地图的视口信息\n    private _rect: Rectangle = new Rectangle();\n    //用来存放地图的视口扩充区域\n    private _paddingRect: Rectangle = new Rectangle();\n    //地图的显示对象\n    private _mapSprite: Sprite = null; //地图的显示对象\n    private _layerArray: any[] = []; //这里保存所有的MapLayer对象\n    private _renderLayerArray: any[] = [];//这里保存需要渲染的MapLayer对象\n    private _gridArray: any[] = []; //保存所有的块数据\n    //地图块相关的\n    private _showGridKey: boolean = false; //是否显示块边界线（用来调试用）\n    private _totalGridNum: number = 0; //一层中的GridSprite的总数\n    private _gridW: number = 0; //地图的横向块数\n    private _gridH: number = 0; //地图的坚向块数\n    private _gridWidth: number = 450; //块的默认宽度\n    private _gridHeight: number = 450; //块的默认高度\n\n    private _tileSetArray: any[] = []; //用来存放还需要哪些儿纹理等待加载\n    private _currTileSet: TileSet = null; //正在加载的纹理需要的数据源\n    private _completeHandler: Handler = null; //地图创建完成的回调函数\n    //用来裁剪块的区域（有当前视口和上次视口显示多少的块，就能哪些儿块需要显示或隐藏\n    private _mapRect: GRect = new GRect(); //当前视口显示的块范围\n    private _mapLastRect: GRect = new GRect(); //上次视口显示的块范围\n    private _index: number = 0;\n    private _animationDic: any = {}; //需要创建的动画数据\n    private _properties: any; //当前地图的自定义属性\n    private _tileProperties: any = {}; //图块属性\n    private _tileProperties2: any = {};\n    //默认的地图类型（具体要看JSON文件）\n    private _orientation: string = \"orthogonal\";\n    //默认的tile渲染顺序（具体要看JSON文件）\n    private _renderOrder: string = \"right-down\";\n    //调试用的颜色组合\n    private _colorArray: any[] = [\"FF\", \"00\", \"33\", \"66\"];\n    //缩放相关的操作\n    private _scale: number = 1;\n    private _pivotScaleX: number = 0.5;\n    private _pivotScaleY: number = 0.5;\n    private _centerX: number = 0;\n    private _centerY: number = 0;\n    /**@internal */\n    _viewPortX: number = 0;\n    /**@internal */\n    _viewPortY: number = 0;\n    private _viewPortWidth: number = 0;\n    private _viewPortHeight: number = 0;\n    //是否开启线性取样\n    private _enableLinear: boolean = true;\n    //资源的相对路径\n    private _resPath: string;\n    private _pathArray: any[];\n    //把地图限制在显示区域\n    private _limitRange: boolean = false;\n    /**\n     * 是否自动缓存没有动画的地块\n     */\n    autoCache: boolean = true;\n    /**\n     * 自动缓存类型,地图较大时建议使用normal\n     */\n    autoCacheType: string = \"normal\";\n    /**\n     * 是否合并图层,开启合并图层时，图层属性内可添加layer属性，运行时将会将相邻的layer属性相同的图层进行合并以提高性能\n     */\n    enableMergeLayer: boolean = false;\n    /**\n     * 是否移除被覆盖的格子,地块可添加type属性，type不为0时表示不透明，被不透明地块遮挡的地块将会被剔除以提高性能\n     */\n    removeCoveredTile: boolean = false;\n    /**\n     * 是否显示大格子里显示的贴图数量\n     */\n    showGridTextureCount: boolean = false;\n\n    /**\n     * 是否调整地块边缘消除缩放导致的缝隙\n     */\n    antiCrack: boolean = true;\n\n    /**\n     * 是否在加载完成之后cache所有大格子\n     */\n    cacheAllAfterInit: boolean = false;\n\n    constructor() {\n\n    }\n\n    /**\n     * 创建地图\n     * @param\tmapName \t\tJSON文件名字\n     * @param\tviewRect \t\t视口区域\n     * @param\tcompleteHandler 地图创建完成的回调函数\n     * @param\tviewRectPadding 视口扩充区域，把视口区域上、下、左、右扩充一下，防止视口移动时的穿帮\n     * @param\tgridSize \t\tgrid大小\n     * @param\tenableLinear \t是否开启线性取样（为false时，可以解决地图黑线的问题，但画质会锐化）\n     * @param\tlimitRange\t\t把地图限制在显示区域\n     */\n    createMap(mapName: string, viewRect: Rectangle, completeHandler: Handler, viewRectPadding: Rectangle = null, gridSize: Point = null, enableLinear: boolean = true, limitRange: boolean = false): void {\n        this._enableLinear = enableLinear;\n        this._limitRange = limitRange;\n        this._rect.x = viewRect.x;\n        this._rect.y = viewRect.y;\n        this._rect.width = viewRect.width;\n        this._rect.height = viewRect.height;\n        this._viewPortWidth = viewRect.width / this._scale;\n        this._viewPortHeight = viewRect.height / this._scale;\n        this._completeHandler = completeHandler;\n        if (viewRectPadding) {\n            this._paddingRect.copyFrom(viewRectPadding);\n        }\n        else {\n            this._paddingRect.setTo(0, 0, 0, 0);\n        }\n        if (gridSize) {\n            this._gridWidth = gridSize.x;\n            this._gridHeight = gridSize.y;\n        }\n        var tIndex: number = mapName.lastIndexOf(\"/\");\n        if (tIndex > -1) {\n            this._resPath = mapName.substr(0, tIndex);\n            this._pathArray = this._resPath.split(\"/\");\n        }\n        else {\n            this._resPath = \"\";\n            this._pathArray = [];\n        }\n\n        ILaya.loader.fetch(mapName, \"json\").then(content => this.onJsonComplete(content));\n    }\n\n    /**\n     * json文件读取成功后，解析里面的纹理数据，进行加载\n     * @param\te JSON数据\n     */\n    private onJsonComplete(tJsonData: any): void {\n        this._mapSprite = new Sprite();\n        ILaya.stage.addChild(this._mapSprite);\n        this._jsonData = tJsonData;\n\n        this._properties = tJsonData.properties;\n        this._orientation = tJsonData.orientation;\n        this._renderOrder = tJsonData.renderorder;\n        this._mapW = tJsonData.width;\n        this._mapH = tJsonData.height;\n\n        this._mapTileW = tJsonData.tilewidth;\n        this._mapTileH = tJsonData.tileheight;\n\n        this._width = this._mapTileW * this._mapW;\n        this._height = this._mapTileH * this._mapH;\n\n        if (this._orientation == TiledMap.ORIENTATION_STAGGERED) {\n            this._height = (0.5 + this._mapH * 0.5) * this._mapTileH;\n        }\n\n        this._mapLastRect.top = this._mapLastRect.bottom = this._mapLastRect.left = this._mapLastRect.right = -1;\n\n        var tArray: any[] = tJsonData.tilesets;\n        var tileset: any;\n        var tTileSet: TileSet;\n        var i: number = 0;\n        for (i = 0; i < tArray.length; i++) {\n            tileset = tArray[i];\n            tTileSet = new TileSet();\n            tTileSet.init(tileset);\n            if (tTileSet.properties && tTileSet.properties.ignore) continue;\n            this._tileProperties[i] = tTileSet.tileproperties;\n            this.addTileProperties(tTileSet.tileproperties);\n            this._tileSetArray.push(tTileSet);\n            //动画数据\n            var tTiles: any = tileset.tiles;\n            if (tTiles) {\n                for (var p in tTiles) {\n                    var tAnimation: any[] = tTiles[p].animation;\n                    if (tAnimation) {\n                        var tAniData: TileMapAniData = new TileMapAniData();\n                        this._animationDic[p] = tAniData;\n                        tAniData.image = tileset.image;\n                        for (var j: number = 0; j < tAnimation.length; j++) {\n                            var tAnimationItem: any = tAnimation[j];\n                            tAniData.mAniIdArray.push(tAnimationItem.tileid);\n                            tAniData.mDurationTimeArray.push(tAnimationItem.duration);\n                        }\n                    }\n                }\n            }\n        }\n\n        this._tileTexSetArr.push(null);\n        if (this._tileSetArray.length > 0) {\n            tTileSet = this._currTileSet = this._tileSetArray.shift();\n\n            var tPath: string = this.mergePath(this._resPath, tTileSet.image);\n            ILaya.loader.load(tPath).then(tex => this.onTextureComplete(tex));\n        }\n    }\n\n    /**\n     * 合并路径\n     * @param\tresPath\n     * @param\trelativePath\n     * @return\n     */\n    private mergePath(resPath: string, relativePath: string): string {\n        var tResultPath: string = \"\";\n        var tImageArray: any[] = relativePath.split(\"/\");\n        var tParentPathNum: number = 0;\n        var i: number = 0;\n        for (i = tImageArray.length - 1; i >= 0; i--) {\n            if (tImageArray[i] == \"..\") {\n                tParentPathNum++;\n            }\n        }\n        if (tParentPathNum == 0) {\n            if (this._pathArray.length > 0) {\n                tResultPath = resPath + \"/\" + relativePath;\n            }\n            else {\n                tResultPath = relativePath;\n            }\n\n            return tResultPath;\n        }\n        var tSrcNum: number = this._pathArray.length - tParentPathNum;\n        if (tSrcNum < 0) {\n            console.log(\"[error]path does not exist\", this._pathArray, tImageArray, resPath, relativePath);\n        }\n        for (i = 0; i < tSrcNum; i++) {\n            if (i == 0) {\n                tResultPath += this._pathArray[i];\n            }\n            else {\n                tResultPath = tResultPath + \"/\" + this._pathArray[i];\n            }\n        }\n        for (i = tParentPathNum; i < tImageArray.length; i++) {\n            tResultPath = tResultPath + \"/\" + tImageArray[i];\n        }\n        return tResultPath;\n    }\n\n    private _texutreStartDic: any = {};\n    /**\n     * 纹理加载完成，如果所有的纹理加载，开始初始化地图\n     * @param\ttex 纹理数据\n     */\n    private onTextureComplete(tTexture: Texture): void {\n        var json: any = this._jsonData;\n        if (!this._enableLinear)\n            tTexture.bitmap.filterMode = FilterMode.Point;\n        this._texArray.push(tTexture);\n        var tSubTexture: Texture = null;\n\n        //var tVersion:int = json.viersion;\n        var tTileSet: TileSet = this._currTileSet;\n        var tTileTextureW: number = tTileSet.tilewidth;\n        var tTileTextureH: number = tTileSet.tileheight;\n        var tImageWidth: number = tTileSet.imagewidth;\n        var tImageHeight: number = tTileSet.imageheight;\n        var tFirstgid: number = tTileSet.firstgid;\n\n        var tTileWNum: number = Math.floor((tImageWidth - tTileSet.margin - tTileTextureW) / (tTileTextureW + tTileSet.spacing)) + 1;\n        var tTileHNum: number = Math.floor((tImageHeight - tTileSet.margin - tTileTextureH) / (tTileTextureH + tTileSet.spacing)) + 1;\n\n        var tTileTexSet: TileTexSet = null;\n        this._texutreStartDic[tTileSet.image] = this._tileTexSetArr.length;\n        for (var i: number = 0; i < tTileHNum; i++) {\n            for (var j: number = 0; j < tTileWNum; j++) {\n                tTileTexSet = new TileTexSet();\n                tTileTexSet.offX = tTileSet.titleoffsetX;\n                tTileTexSet.offY = tTileSet.titleoffsetY - (tTileTextureH - this._mapTileH);\n                //tTileTexSet.texture = Texture.create(tTexture, tTileSet.margin + (tTileTextureW + tTileSet.spacing) * j, tTileSet.margin + (tTileTextureH + tTileSet.spacing) * i, tTileTextureW, tTileTextureH);\n                tTileTexSet.texture = Texture.createFromTexture(tTexture, tTileSet.margin + (tTileTextureW + tTileSet.spacing) * j, tTileSet.margin + (tTileTextureH + tTileSet.spacing) * i, tTileTextureW, tTileTextureH);\n                if (this.antiCrack)\n                    this.adptTexture(tTileTexSet.texture);\n                this._tileTexSetArr.push(tTileTexSet);\n                tTileTexSet.gid = this._tileTexSetArr.length;\n            }\n        }\n\n        if (this._tileSetArray.length > 0) {\n            tTileSet = this._currTileSet = this._tileSetArray.shift();\n            var tPath: string = this.mergePath(this._resPath, tTileSet.image);\n            ILaya.loader.load(tPath).then(tex => this.onTextureComplete(tex));\n        }\n        else {\n            this._currTileSet = null;\n            this.initMap();\n        }\n    }\n\n    private adptTexture(tex: Texture): void {\n        if (!tex) return;\n        var pX: number = tex.uv[0];\n        var pX1: number = tex.uv[2];\n        var pY: number = tex.uv[1];\n        var pY1: number = tex.uv[7];\n        var dW: number = 1 / tex.bitmap.width;\n        var dH: number = 1 / tex.bitmap.height;\n        var Tex: any = tex;\n        Tex.uv[0] = Tex.uv[6] = pX + dW;\n        Tex.uv[2] = Tex.uv[4] = pX1 - dW;\n        Tex.uv[1] = Tex.uv[3] = pY + dH;\n        Tex.uv[5] = Tex.uv[7] = pY1 - dH;\n    }\n\n    /**\n     * 初始化地图\n     */\n    private initMap(): void {\n        var i: number, n: number;\n        for (var p in this._animationDic) {\n            var tAniData: TileMapAniData = this._animationDic[p];\n            var gStart: number;\n            gStart = this._texutreStartDic[tAniData.image];\n            var tTileTexSet: TileTexSet = this.getTexture(parseInt(p) + gStart);\n            if (tAniData.mAniIdArray.length > 0) {\n                tTileTexSet.textureArray = [];\n                tTileTexSet.durationTimeArray = tAniData.mDurationTimeArray;\n                tTileTexSet.isAnimation = true;\n                tTileTexSet.animationTotalTime = 0;\n                for (i = 0, n = tTileTexSet.durationTimeArray.length; i < n; i++) {\n                    tTileTexSet.animationTotalTime += tTileTexSet.durationTimeArray[i];\n                }\n                for (i = 0, n = tAniData.mAniIdArray.length; i < n; i++) {\n                    var tTexture: TileTexSet = this.getTexture(tAniData.mAniIdArray[i] + gStart);\n                    tTileTexSet.textureArray.push(tTexture);\n                }\n            }\n        }\n\n        this._gridWidth = Math.floor(this._gridWidth / this._mapTileW) * this._mapTileW;\n        this._gridHeight = Math.floor(this._gridHeight / this._mapTileH) * this._mapTileH;\n        if (this._gridWidth < this._mapTileW) {\n            this._gridWidth = this._mapTileW;\n        }\n        if (this._gridHeight < this._mapTileH) {\n            this._gridHeight = this._mapTileH;\n        }\n\n        this._gridW = Math.ceil(this._width / this._gridWidth);\n        this._gridH = Math.ceil(this._height / this._gridHeight);\n        this._totalGridNum = this._gridW * this._gridH;\n        for (i = 0; i < this._gridH; i++) {\n            var tGridArray: any[] = [];\n            this._gridArray.push(tGridArray);\n            for (var j: number = 0; j < this._gridW; j++) {\n                tGridArray.push(null);\n            }\n        }\n\n        var tLayerArray: any[] = this._jsonData.layers;\n        var isFirst: boolean = true;\n        var tTarLayerID: number = 1;\n        var tLayerTarLayerName: string;\n        var preLayerTarName: string;\n        var preLayer: MapLayer;\n\n        //创建地图层级\n        for (var tLayerLoop: number = 0; tLayerLoop < tLayerArray.length; tLayerLoop++) {\n            var tLayerData: any = tLayerArray[tLayerLoop];\n            if (tLayerData.visible == true) //如果不显示，那么也没必要创建\n            {\n                var tMapLayer: MapLayer = new MapLayer();\n                tMapLayer.init(tLayerData, this);\n                if (!this.enableMergeLayer) {\n                    this._mapSprite.addChild(tMapLayer);\n                    this._renderLayerArray.push(tMapLayer);\n                } else {\n                    tLayerTarLayerName = tMapLayer.getLayerProperties(\"layer\");\n                    isFirst = isFirst || (!preLayer) || (tLayerTarLayerName != preLayerTarName);\n                    if (isFirst) {\n                        isFirst = false;\n                        tMapLayer.tarLayer = tMapLayer;\n                        preLayer = tMapLayer;\n                        this._mapSprite.addChild(tMapLayer);\n                        this._renderLayerArray.push(tMapLayer);\n                    } else {\n                        tMapLayer.tarLayer = preLayer;\n                    }\n                    preLayerTarName = tLayerTarLayerName;\n                }\n\n\n                this._layerArray.push(tMapLayer);\n            }\n        }\n        if (this.removeCoveredTile) {\n            this.adptTiledMapData();\n        }\n        if (this.cacheAllAfterInit) {\n            this.cacheAllGrid();\n        }\n        this.moveViewPort(this._rect.x, this._rect.y);\n\n        if (this._completeHandler != null) {\n            this._completeHandler.run();\n        }\n        //这里应该发送消息，通知上层，地图创建完成\n    }\n\n    private addTileProperties(tileDataDic: any): void {\n        var key: string;\n        for (key in tileDataDic) {\n            this._tileProperties2[key] = tileDataDic[key];\n        }\n    }\n\n    getTileUserData(id: number, sign: string, defaultV: any = null): any {\n        if (!this._tileProperties2 || !this._tileProperties2[id] || !(sign in this._tileProperties2[id])) return defaultV;\n        return this._tileProperties2[id][sign];\n    }\n\n    private adptTiledMapData(): void {\n        var i: number, len: number;\n        len = this._layerArray.length;\n        var tLayer: MapLayer;\n        var noNeeds: any = {};\n        var tDatas: any[];\n        for (i = len - 1; i >= 0; i--) {\n            tLayer = this._layerArray[i];\n            tDatas = tLayer._mapData;\n            if (!tDatas) continue;\n            this.removeCoverd(tDatas, noNeeds);\n            this.collectCovers(tDatas, noNeeds, i);\n        }\n    }\n\n    private removeCoverd(datas: any[], noNeeds: any): void {\n        var i: number, len: number;\n        len = datas.length;\n        for (i = 0; i < len; i++) {\n            if (noNeeds[i]) {\n                datas[i] = 0;\n            }\n        }\n    }\n\n    private collectCovers(datas: any[], noNeeds: any, layer: number): void {\n        var i: number, len: number;\n        len = datas.length;\n        var tTileData: number;\n        var isCover: number;\n        for (i = 0; i < len; i++) {\n            tTileData = datas[i];\n            if (tTileData > 0) {\n                isCover = this.getTileUserData(tTileData - 1, \"type\", 0);\n                if (isCover > 0) {\n                    noNeeds[i] = tTileData;\n                }\n            }\n        }\n    }\n    /**\n     * 得到一块指定的地图纹理\n     * @param\tindex 纹理的索引值，默认从1开始\n     * @return\n     */\n    getTexture(index: number): TileTexSet {\n        if (index < this._tileTexSetArr.length) {\n            return this._tileTexSetArr[index];\n        }\n        return null;\n    }\n\n    /**\n     * 得到地图的自定义属性\n     * @param\tname\t\t属性名称\n     * @return\n     */\n    getMapProperties(name: string): any {\n        if (this._properties) {\n            return this._properties[name];\n        }\n        return null;\n    }\n\n    /**\n     * 得到tile自定义属性\n     * @param\tindex\t\t地图块索引\n     * @param\tid\t\t\t具体的TileSetID\n     * @param\tname\t\t属性名称\n     * @return\n     */\n    getTileProperties(index: number, id: number, name: string): any {\n        if (this._tileProperties[index] && this._tileProperties[index][id]) {\n            return this._tileProperties[index][id][name];\n        }\n        return null;\n    }\n\n    /**\n     * 通过纹理索引，生成一个可控制物件\n     * @param\tindex 纹理的索引值，默认从1开始\n     * @return\n     */\n    getSprite(index: number, width: number, height: number): GridSprite {\n        if (0 < this._tileTexSetArr.length) {\n            var tGridSprite: GridSprite = new GridSprite();\n            tGridSprite.initData(this, true);\n            tGridSprite.size(width, height);\n            var tTileTexSet: TileTexSet = this._tileTexSetArr[index];\n            if (tTileTexSet != null && tTileTexSet.texture != null) {\n                if (tTileTexSet.isAnimation) {\n                    var tAnimationSprite: TileAniSprite = new TileAniSprite();\n                    this._index++;\n                    tAnimationSprite.setTileTextureSet(this._index.toString(), tTileTexSet);\n                    tGridSprite.addAniSprite(tAnimationSprite);\n                    tGridSprite.addChild(tAnimationSprite);\n                }\n                else {\n                    tGridSprite.graphics.drawImage(tTileTexSet.texture, 0, 0, width, height);\n                }\n                tGridSprite.drawImageNum++;\n            }\n            return tGridSprite;\n        }\n        return null;\n    }\n\n    /**\n     * 设置视口的缩放中心点（例如：scaleX= scaleY= 0.5,就是以视口中心缩放）\n     * @param\tscaleX\n     * @param\tscaleY\n     */\n    setViewPortPivotByScale(scaleX: number, scaleY: number): void {\n        this._pivotScaleX = scaleX;\n        this._pivotScaleY = scaleY;\n    }\n\n    /**\n     * 设置地图缩放\n     * @param\tscale\n     */\n    set scale(scale: number) {\n        if (scale <= 0)\n            return;\n        this._scale = scale;\n        this._viewPortWidth = this._rect.width / scale;\n        this._viewPortHeight = this._rect.height / scale;\n        this._mapSprite.scale(this._scale, this._scale);\n        this.updateViewPort();\n    }\n\n    /**\n     * 得到当前地图的缩放\n     */\n    get scale(): number {\n        return this._scale;\n    }\n\n    /**\n     * 移动视口\n     * @param\tmoveX 视口的坐标x\n     * @param\tmoveY 视口的坐标y\n     */\n    moveViewPort(moveX: number, moveY: number): void {\n        this._x = -moveX;\n        this._y = -moveY;\n        this._rect.x = moveX;\n        this._rect.y = moveY;\n        this.updateViewPort();\n    }\n\n    /**\n     * 改变视口大小\n     * @param\tmoveX\t视口的坐标x\n     * @param\tmoveY\t视口的坐标y\n     * @param\twidth\t视口的宽\n     * @param\theight\t视口的高\n     */\n    changeViewPort(moveX: number, moveY: number, width: number, height: number): void {\n        if (moveX == this._rect.x && moveY == this._rect.y && width == this._rect.width && height == this._rect.height) return;\n        this._x = -moveX;\n        this._y = -moveY;\n        this._rect.x = moveX;\n        this._rect.y = moveY;\n        this._rect.width = width;\n        this._rect.height = height;\n        this._viewPortWidth = width / this._scale;\n        this._viewPortHeight = height / this._scale;\n        this.updateViewPort();\n    }\n\n    /**\n     * 在锚点的基础上计算，通过宽和高，重新计算视口\n     * @param\twidth\t\t新视口宽\n     * @param\theight\t\t新视口高\n     * @param\trect\t\t返回的结果\n     * @return\n     */\n    changeViewPortBySize(width: number, height: number, rect: Rectangle = null): Rectangle {\n        if (rect == null) {\n            rect = new Rectangle();\n        }\n        this._centerX = this._rect.x + this._rect.width * this._pivotScaleX;\n        this._centerY = this._rect.y + this._rect.height * this._pivotScaleY;\n        rect.x = this._centerX - width * this._pivotScaleX;\n        rect.y = this._centerY - height * this._pivotScaleY;\n        rect.width = width;\n        rect.height = height;\n        this.changeViewPort(rect.x, rect.y, rect.width, rect.height);\n        return rect;\n    }\n\n    /**\n     * 刷新视口\n     */\n    private updateViewPort(): void {\n        //_rect.x和rect.y是内部坐标，会自动叠加缩放\n        this._centerX = this._rect.x + this._rect.width * this._pivotScaleX;\n        this._centerY = this._rect.y + this._rect.height * this._pivotScaleY;\n        var posChanged: boolean = false;\n        var preValue: number = this._viewPortX;\n        this._viewPortX = this._centerX - this._rect.width * this._pivotScaleX / this._scale;\n        if (preValue != this._viewPortX) {\n            posChanged = true;\n        } else {\n            preValue = this._viewPortY;\n        }\n        this._viewPortY = this._centerY - this._rect.height * this._pivotScaleY / this._scale;\n        if (!posChanged && preValue != this._viewPortY) {\n            posChanged = true;\n        }\n        if (this._limitRange) {\n            var tRight: number = this._viewPortX + this._viewPortWidth;\n            if (tRight > this._width) {\n                this._viewPortX = this._width - this._viewPortWidth;\n            }\n            var tBottom: number = this._viewPortY + this._viewPortHeight;\n            if (tBottom > this._height) {\n                this._viewPortY = this._height - this._viewPortHeight;\n            }\n            if (this._viewPortX < 0) {\n                this._viewPortX = 0;\n            }\n            if (this._viewPortY < 0) {\n                this._viewPortY = 0;\n            }\n        }\n        var tPaddingRect: Rectangle = this._paddingRect;\n        this._mapRect.top = Math.floor((this._viewPortY - tPaddingRect.y) / this._gridHeight);\n        this._mapRect.bottom = Math.floor((this._viewPortY + this._viewPortHeight + tPaddingRect.height + tPaddingRect.y) / this._gridHeight);\n        this._mapRect.left = Math.floor((this._viewPortX - tPaddingRect.x) / this._gridWidth);\n        this._mapRect.right = Math.floor((this._viewPortX + this._viewPortWidth + tPaddingRect.width + tPaddingRect.x) / this._gridWidth);\n        if (this._mapRect.top != this._mapLastRect.top || this._mapRect.bottom != this._mapLastRect.bottom || this._mapRect.left != this._mapLastRect.left || this._mapRect.right != this._mapLastRect.right) {\n            this.clipViewPort();\n            this._mapLastRect.top = this._mapRect.top;\n            this._mapLastRect.bottom = this._mapRect.bottom;\n            this._mapLastRect.left = this._mapRect.left;\n            this._mapLastRect.right = this._mapRect.right;\n            posChanged = true;\n        }\n\n        if (!posChanged) return;\n\n        var tMapLayer: MapLayer;\n        var len: number = this._renderLayerArray.length;\n        for (var i: number = 0; i < len; i++) {\n            tMapLayer = this._renderLayerArray[i];\n            if (tMapLayer._gridSpriteArray.length > 0)\n                tMapLayer.updateGridPos();\n        }\n    }\n\n    /**\n     * GRID裁剪\n     */\n    private clipViewPort(): void {\n        var tSpriteNum: number = 0;\n        var tSprite: Sprite;\n        var tIndex: number = 0;\n        var tSub: number = 0;\n        var tAdd: number = 0;\n        var i: number, j: number;\n        if (this._mapRect.left > this._mapLastRect.left) {\n            //裁剪\n            tSub = this._mapRect.left - this._mapLastRect.left;\n            if (tSub > 0) {\n                for (j = this._mapLastRect.left; j < this._mapLastRect.left + tSub; j++) {\n                    for (i = this._mapLastRect.top; i <= this._mapLastRect.bottom; i++) {\n                        this.hideGrid(j, i);\n                    }\n                }\n            }\n        }\n        else {\n            //增加\n            tAdd = Math.min(this._mapLastRect.left, this._mapRect.right + 1) - this._mapRect.left;\n            if (tAdd > 0) {\n                for (j = this._mapRect.left; j < this._mapRect.left + tAdd; j++) {\n                    for (i = this._mapRect.top; i <= this._mapRect.bottom; i++) {\n                        this.showGrid(j, i);\n                    }\n                }\n            }\n        }\n        if (this._mapRect.right > this._mapLastRect.right) {\n            //增加\n            tAdd = this._mapRect.right - this._mapLastRect.right;\n            if (tAdd > 0) {\n                for (j = Math.max(this._mapLastRect.right + 1, this._mapRect.left); j <= this._mapLastRect.right + tAdd; j++) {\n                    for (i = this._mapRect.top; i <= this._mapRect.bottom; i++) {\n                        this.showGrid(j, i);\n                    }\n                }\n            }\n        }\n        else {\n            //裁剪\n            tSub = this._mapLastRect.right - this._mapRect.right\n            if (tSub > 0) {\n                for (j = this._mapRect.right + 1; j <= this._mapRect.right + tSub; j++) {\n                    for (i = this._mapLastRect.top; i <= this._mapLastRect.bottom; i++) {\n                        this.hideGrid(j, i);\n                    }\n                }\n            }\n        }\n        if (this._mapRect.top > this._mapLastRect.top) {\n            //裁剪\n            tSub = this._mapRect.top - this._mapLastRect.top;\n            if (tSub > 0) {\n                for (i = this._mapLastRect.top; i < this._mapLastRect.top + tSub; i++) {\n                    for (j = this._mapLastRect.left; j <= this._mapLastRect.right; j++) {\n                        this.hideGrid(j, i);\n                    }\n                }\n            }\n\n        }\n        else {\n            //增加\n            tAdd = Math.min(this._mapLastRect.top, this._mapRect.bottom + 1) - this._mapRect.top;\n            if (tAdd > 0) {\n                for (i = this._mapRect.top; i < this._mapRect.top + tAdd; i++) {\n                    for (j = this._mapRect.left; j <= this._mapRect.right; j++) {\n                        this.showGrid(j, i);\n                    }\n                }\n            }\n\n        }\n        if (this._mapRect.bottom > this._mapLastRect.bottom) {\n            //增加\n            tAdd = this._mapRect.bottom - this._mapLastRect.bottom;\n            if (tAdd > 0) {\n                for (i = Math.max(this._mapLastRect.bottom + 1, this._mapRect.top); i <= this._mapLastRect.bottom + tAdd; i++) {\n                    for (j = this._mapRect.left; j <= this._mapRect.right; j++) {\n                        this.showGrid(j, i);\n                    }\n                }\n            }\n        }\n        else {\n            //裁剪\n            tSub = this._mapLastRect.bottom - this._mapRect.bottom\n            if (tSub > 0) {\n                for (i = this._mapRect.bottom + 1; i <= this._mapRect.bottom + tSub; i++) {\n                    for (j = this._mapLastRect.left; j <= this._mapLastRect.right; j++) {\n                        this.hideGrid(j, i);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * 显示指定的GRID\n     * @param\tgridX\n     * @param\tgridY\n     */\n    private showGrid(gridX: number, gridY: number): void {\n        if (gridX < 0 || gridX >= this._gridW || gridY < 0 || gridY >= this._gridH) {\n            return;\n        }\n        var i: number, j: number;\n        var tGridSprite: GridSprite\n        var tTempArray: any[] = this._gridArray[gridY][gridX];\n        if (tTempArray == null) {\n            tTempArray = this.getGridArray(gridX, gridY);\n        }\n        else {\n            for (i = 0; i < tTempArray.length && i < this._layerArray.length; i++) {\n                var tLayerSprite: Sprite = this._layerArray[i];\n                if (tLayerSprite && tTempArray[i]) {\n                    tGridSprite = tTempArray[i];\n                    if (tGridSprite.visible == false && tGridSprite.drawImageNum > 0) {\n                        tGridSprite.show();\n                    }\n                }\n            }\n        }\n    }\n\n    private cacheAllGrid(): void {\n        var i: number, j: number;\n        var tempArr: any[];\n        for (i = 0; i < this._gridW; i++) {\n            for (j = 0; j < this._gridH; j++) {\n                tempArr = this.getGridArray(i, j);\n                this.cacheGridsArray(tempArr);\n            }\n        }\n\n    }\n    private static _tempCanvas: any;\n    private cacheGridsArray(arr: any[]): void {\n        var canvas: any;\n        if (!TiledMap._tempCanvas) {\n            TiledMap._tempCanvas = new HTMLCanvas();\n            var tx: Context = TiledMap._tempCanvas.context;\n            if (!tx) {\n                tx = TiledMap._tempCanvas.getContext('2d');\t//如果是webGL的话，这个会返回WebGLContext2D\n\n                //tx.__tx = 0;\n                //tx.__ty = 0;\n            }\n        }\n        canvas = TiledMap._tempCanvas;\n        canvas.context.asBitmap = false\n\n\n        var i: number, len: number;\n        len = arr.length;\n        var tGrid: GridSprite;\n        for (i = 0; i < len; i++) {\n            tGrid = arr[i];\n            canvas.clear();\n            canvas.size(1, 1);\n            tGrid.render(canvas.context, 0, 0);\n            tGrid.hide();\n        }\n        canvas.clear();\n        canvas.size(1, 1);\n    }\n\n    private getGridArray(gridX: number, gridY: number): any[] {\n        var i: number, j: number;\n        var tGridSprite: GridSprite\n        var tTempArray: any[] = this._gridArray[gridY][gridX];\n        if (tTempArray == null) {\n            tTempArray = this._gridArray[gridY][gridX] = [];\n\n            var tLeft: number = 0;\n            var tRight: number = 0;\n            var tTop: number = 0;\n            var tBottom: number = 0;\n\n            var tGridWidth: number = this._gridWidth\n            var tGridHeight: number = this._gridHeight;\n            switch (this.orientation) {\n                case TiledMap.ORIENTATION_ISOMETRIC: //45度角\n                    tLeft = Math.floor(gridX * tGridWidth);\n                    tRight = Math.floor(gridX * tGridWidth + tGridWidth);\n                    tTop = Math.floor(gridY * tGridHeight);\n                    tBottom = Math.floor(gridY * tGridHeight + tGridHeight);\n                    var tLeft1: number, tRight1: number, tTop1: number, tBottom1: number;\n                    break;\n                case TiledMap.ORIENTATION_STAGGERED: //45度交错地图\n                    tLeft = Math.floor(gridX * tGridWidth / this._mapTileW);\n                    tRight = Math.floor((gridX * tGridWidth + tGridWidth) / this._mapTileW);\n                    tTop = Math.floor(gridY * tGridHeight / (this._mapTileH / 2));\n                    tBottom = Math.floor((gridY * tGridHeight + tGridHeight) / (this._mapTileH / 2));\n                    break;\n                case TiledMap.ORIENTATION_ORTHOGONAL: //直角\n                    tLeft = Math.floor(gridX * tGridWidth / this._mapTileW);\n                    tRight = Math.floor((gridX * tGridWidth + tGridWidth) / this._mapTileW);\n                    tTop = Math.floor(gridY * tGridHeight / this._mapTileH);\n                    tBottom = Math.floor((gridY * tGridHeight + tGridHeight) / this._mapTileH);\n                    break;\n                case TiledMap.ORIENTATION_HEXAGONAL: //六边形\n                    var tHeight: number = this._mapTileH * 2 / 3;\n                    tLeft = Math.floor(gridX * tGridWidth / this._mapTileW);\n                    tRight = Math.ceil((gridX * tGridWidth + tGridWidth) / this._mapTileW);\n                    tTop = Math.floor(gridY * tGridHeight / tHeight);\n                    tBottom = Math.ceil((gridY * tGridHeight + tGridHeight) / tHeight);\n                    break;\n\n            }\n\n            var tLayer: MapLayer = null;\n            var tTGridSprite: GridSprite;\n            var tDrawMapLayer: MapLayer;\n            for (var z: number = 0; z < this._layerArray.length; z++) {\n                tLayer = this._layerArray[z];\n\n                if (this.enableMergeLayer) {\n                    if (tLayer.tarLayer != tDrawMapLayer) {\n                        tTGridSprite = null;\n                        tDrawMapLayer = tLayer.tarLayer;\n                    }\n                    if (!tTGridSprite) {\n                        tTGridSprite = tDrawMapLayer.getDrawSprite(gridX, gridY);\n                        tTempArray.push(tTGridSprite);\n                        //tDrawMapLayer.addChild(tTGridSprite);\n                    }\n                    tGridSprite = tTGridSprite;\n                }\n                else {\n                    tGridSprite = tLayer.getDrawSprite(gridX, gridY);\n                    tTempArray.push(tGridSprite);\n                }\n\n                var tColorStr: string;\n                if (this._showGridKey) {\n                    tColorStr = \"#\";\n                    tColorStr += this._colorArray[Math.floor(Math.random() * this._colorArray.length)];\n                    tColorStr += this._colorArray[Math.floor(Math.random() * this._colorArray.length)];\n                    tColorStr += this._colorArray[Math.floor(Math.random() * this._colorArray.length)];\n                }\n                switch (this.orientation) {\n                    case TiledMap.ORIENTATION_ISOMETRIC: //45度角\n                        var tHalfTileHeight: number = this.tileHeight / 2;\n                        var tHalfTileWidth: number = this.tileWidth / 2;\n                        var tHalfMapWidth: number = this._width / 2;\n                        tTop1 = Math.floor(tTop / tHalfTileHeight);\n                        tBottom1 = Math.floor(tBottom / tHalfTileHeight);\n                        tLeft1 = this._mapW + Math.floor((tLeft - tHalfMapWidth) / tHalfTileWidth);\n                        tRight1 = this._mapW + Math.floor((tRight - tHalfMapWidth) / tHalfTileWidth);\n\n                        var tMapW: number = this._mapW * 2;\n                        var tMapH: number = this._mapH * 2;\n\n                        if (tTop1 < 0) {\n                            tTop1 = 0;\n                        }\n                        if (tTop1 >= tMapH) {\n                            tTop1 = tMapH - 1;\n                        }\n                        if (tBottom1 < 0) {\n                            tBottom = 0;\n                        }\n                        if (tBottom1 >= tMapH) {\n                            tBottom1 = tMapH - 1;\n                        }\n                        tGridSprite.zOrder = this._totalGridNum * z + gridY * this._gridW + gridX;\n                        for (i = tTop1; i < tBottom1; i++) {\n                            for (j = 0; j <= i; j++) {\n                                var tIndexX: number = i - j;\n                                var tIndexY: number = j;\n                                var tIndexValue: number = (tIndexX - tIndexY) + this._mapW;\n                                if (tIndexValue > tLeft1 && tIndexValue <= tRight1) {\n                                    if (tLayer.drawTileTexture(tGridSprite, tIndexX, tIndexY)) {\n                                        tGridSprite.drawImageNum++;\n                                    }\n                                }\n                            }\n                        }\n                        break;\n                    case TiledMap.ORIENTATION_STAGGERED: //45度交错地图\n                        tGridSprite.zOrder = z * this._totalGridNum + gridY * this._gridW + gridX;\n                        for (i = tTop; i < tBottom; i++) {\n                            for (j = tLeft; j < tRight; j++) {\n                                if (tLayer.drawTileTexture(tGridSprite, j, i)) {\n                                    tGridSprite.drawImageNum++;\n                                }\n                            }\n                        }\n                        break;\n                    case TiledMap.ORIENTATION_ORTHOGONAL: //直角\n                    case TiledMap.ORIENTATION_HEXAGONAL: //六边形\n                        switch (this._renderOrder) {\n                            case TiledMap.RENDERORDER_RIGHTDOWN:\n                                tGridSprite.zOrder = z * this._totalGridNum + gridY * this._gridW + gridX;\n                                for (i = tTop; i < tBottom; i++) {\n                                    for (j = tLeft; j < tRight; j++) {\n                                        if (tLayer.drawTileTexture(tGridSprite, j, i)) {\n                                            tGridSprite.drawImageNum++;\n                                        }\n                                    }\n                                }\n                                break;\n                            case TiledMap.RENDERORDER_RIGHTUP:\n                                tGridSprite.zOrder = z * this._totalGridNum + (this._gridH - 1 - gridY) * this._gridW + gridX;\n                                for (i = tBottom - 1; i >= tTop; i--) {\n                                    for (j = tLeft; j < tRight; j++) {\n                                        if (tLayer.drawTileTexture(tGridSprite, j, i)) {\n                                            tGridSprite.drawImageNum++;\n                                        }\n                                    }\n                                }\n                                break;\n                            case TiledMap.RENDERORDER_LEFTDOWN:\n                                tGridSprite.zOrder = z * this._totalGridNum + gridY * this._gridW + (this._gridW - 1 - gridX);\n                                for (i = tTop; i < tBottom; i++) {\n                                    for (j = tRight - 1; j >= tLeft; j--) {\n                                        if (tLayer.drawTileTexture(tGridSprite, j, i)) {\n                                            tGridSprite.drawImageNum++;\n                                        }\n                                    }\n                                }\n                                break;\n                            case TiledMap.RENDERORDER_LEFTUP:\n                                tGridSprite.zOrder = z * this._totalGridNum + (this._gridH - 1 - gridY) * this._gridW + (this._gridW - 1 - gridX);\n                                for (i = tBottom - 1; i >= tTop; i--) {\n                                    for (j = tRight - 1; j >= tLeft; j--) {\n                                        if (tLayer.drawTileTexture(tGridSprite, j, i)) {\n                                            tGridSprite.drawImageNum++;\n                                        }\n                                    }\n                                }\n                                break;\n                        }\n                        break;\n                }\n                //没动画了GRID，保存为图片\n                if (!tGridSprite.isHaveAnimation) {\n                    tGridSprite.autoSize = true;\n                    if (this.autoCache)\n                        tGridSprite.cacheAs = this.autoCacheType;\n                    tGridSprite.autoSize = false;\n                }\n\n                if (!this.enableMergeLayer) {\n                    if (tGridSprite.drawImageNum > 0) {\n                        tLayer.addChild(tGridSprite);\n                    }\n                    if (this._showGridKey) {\n                        tGridSprite.graphics.drawRect(0, 0, tGridWidth, tGridHeight, null, tColorStr);\n                    }\n                } else {\n                    if (tTGridSprite && tTGridSprite.drawImageNum > 0 && tDrawMapLayer) {\n                        tDrawMapLayer.addChild(tTGridSprite);\n                    }\n                }\n\n\n            }\n            if (this.enableMergeLayer && this.showGridTextureCount) {\n                if (tTGridSprite) {\n                    tTGridSprite.graphics.fillText(tTGridSprite.drawImageNum + \"\", 20, 20, null, \"#ff0000\", \"left\");\n                }\n            }\n        }\n        return tTempArray;\n    }\n\n    /**\n     * 隐藏指定的GRID\n     * @param\tgridX\n     * @param\tgridY\n     */\n    private hideGrid(gridX: number, gridY: number): void {\n        if (gridX < 0 || gridX >= this._gridW || gridY < 0 || gridY >= this._gridH) {\n            return;\n        }\n        var tTempArray: any[] = this._gridArray[gridY][gridX];\n        if (tTempArray) {\n            var tGridSprite: GridSprite;\n            for (var i: number = 0; i < tTempArray.length; i++) {\n                tGridSprite = tTempArray[i];\n                if (tGridSprite.drawImageNum > 0) {\n                    if (tGridSprite != null) {\n                        tGridSprite.hide();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * 得到对象层上的某一个物品\n     * @param\tlayerName   层的名称\n     * @param\tobjectName\t所找物品的名称\n     * @return\n     */\n    getLayerObject(layerName: string, objectName: string): GridSprite {\n        var tLayer: MapLayer = null;\n        for (var i: number = 0; i < this._layerArray.length; i++) {\n            tLayer = this._layerArray[i];\n            if (tLayer.layerName == layerName) {\n                break;\n            }\n        }\n        if (tLayer) {\n            return tLayer.getObjectByName(objectName);\n        }\n        return null;\n    }\n\n    /**\n     * 销毁地图\n     */\n    destroy(): void {\n        this._orientation = TiledMap.ORIENTATION_ORTHOGONAL;\n        //json数据\n        this._jsonData = null;\n\n        var i: number = 0;\n        var j: number = 0;\n        var z: number = 0;\n\n        this._gridArray = []; //??这里因为跟LAYER中的数据重复，所以不做处理\n        //清除子纹理\n        var tTileTexSet: TileTexSet;\n        for (i = 0; i < this._tileTexSetArr.length; i++) {\n            tTileTexSet = this._tileTexSetArr[i];\n            if (tTileTexSet) {\n                tTileTexSet.clearAll();\n            }\n        }\n        this._tileTexSetArr = [];\n        //清除主纹理\n        var tTexture: Texture;\n        for (i = 0; i < this._texArray.length; i++) {\n            tTexture = this._texArray[i];\n            tTexture.destroy();\n        }\n        this._texArray = [];\n\n        //地图信息中的一些基本数据\n        this._width = 0;\n        this._height = 0;\n        this._mapW = 0;\n        this._mapH = 0;\n        this._mapTileW = 0;\n        this._mapTileH = 0;\n\n        this._rect.setTo(0, 0, 0, 0);\n\n        var tLayer: MapLayer;\n        for (i = 0; i < this._layerArray.length; i++) {\n            tLayer = this._layerArray[i];\n            tLayer.clearAll();\n        }\n\n        this._layerArray = [];\n        this._renderLayerArray = [];\n        if (this._mapSprite) {\n            this._mapSprite.destroy();\n            this._mapSprite = null;\n        }\n\n        //\n        var tDic: any = this._animationDic;\n        for (var p in tDic) {\n            delete tDic[p];\n        }\n\n        this._properties = null;\n        tDic = this._tileProperties;\n        for (p in tDic) {\n            delete tDic[p];\n        }\n\n        this._currTileSet = null;\n        this._completeHandler = null;\n\n        this._mapRect.clearAll();\n        this._mapLastRect.clearAll();\n\n        this._tileSetArray = [];\n\n        this._gridWidth = 450;\n        this._gridHeight = 450;\n\n        this._gridW = 0;\n        this._gridH = 0;\n\n        this._x = 0;\n        this._y = 0;\n\n        this._index = 0;\n\n        this._enableLinear = true;\n        //资源的相对路径\n        this._resPath = null;\n        this._pathArray = null;\n    }\n\n    /****************************地图的基本数据***************************/ /**\n     * 格子的宽度\n     */\n    get tileWidth(): number {\n        return this._mapTileW;\n    }\n\n    /**\n     * 格子的高度\n     */\n    get tileHeight(): number {\n        return this._mapTileH;\n    }\n\n    /**\n     * 地图的宽度\n     */\n    get width(): number {\n        return this._width;\n    }\n\n    /**\n     * 地图的高度\n     */\n    get height(): number {\n        return this._height;\n    }\n\n    /**\n     * 地图横向的格子数\n     */\n    get numColumnsTile(): number {\n        return this._mapW;\n    }\n\n    /**\n     * 地图竖向的格子数\n     */\n    get numRowsTile(): number {\n        return this._mapH;\n    }\n\n    /**\n     * @private\n     * 视口x坐标\n     */\n    get viewPortX(): number {\n        return -this._viewPortX;\n    }\n\n    /**\n     * @private\n     * 视口的y坐标\n     */\n    get viewPortY(): number {\n        return -this._viewPortY;\n    }\n\n    /**\n     * @private\n     * 视口的宽度\n     */\n    get viewPortWidth(): number {\n        return this._viewPortWidth;\n    }\n\n    /**\n     * @private\n     * 视口的高度\n     */\n    get viewPortHeight(): number {\n        return this._viewPortHeight;\n    }\n\n    /**\n     * 地图的x坐标\n     */\n    get x(): number {\n        return this._x;\n    }\n\n    /**\n     * 地图的y坐标\n     */\n    get y(): number {\n        return this._y;\n    }\n\n    /**\n     * 块的宽度\n     */\n    get gridWidth(): number {\n        return this._gridWidth;\n    }\n\n    /**\n     * 块的高度\n     */\n    get gridHeight(): number {\n        return this._gridHeight;\n    }\n\n    /**\n     * 地图的横向块数\n     */\n    get numColumnsGrid(): number {\n        return this._gridW;\n    }\n\n    /**\n     * 地图的坚向块数\n     */\n    get numRowsGrid(): number {\n        return this._gridH;\n    }\n\n    /**\n     * 当前地图类型\n     */\n    get orientation(): string {\n        return this._orientation;\n    }\n\n    /**\n     * tile渲染顺序\n     */\n    get renderOrder(): string {\n        return this._renderOrder;\n    }\n\n    /*****************************************对外接口**********************************************/\n\n    /**\n     * 整个地图的显示容器\n     * @return 地图的显示容器\n     */\n    mapSprite(): Sprite {\n        return this._mapSprite;\n    }\n\n    /**\n     * 得到指定的MapLayer\n     * @param layerName 要找的层名称\n     * @return\n     */\n    getLayerByName(layerName: string): MapLayer {\n        var tMapLayer: MapLayer;\n        for (var i: number = 0; i < this._layerArray.length; i++) {\n            tMapLayer = this._layerArray[i];\n            if (layerName == tMapLayer.layerName) {\n                return tMapLayer;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * 通过索引得MapLayer\n     * @param\tindex 要找的层索引\n     * @return\n     */\n    getLayerByIndex(index: number): MapLayer {\n        if (index < this._layerArray.length) {\n            return this._layerArray[index];\n        }\n        return null;\n    }\n\n}\n\n/**@internal */\nclass GRect {\n    left: number;\n    top: number;\n    right: number;\n    bottom: number;\n\n    clearAll(): void {\n        this.left = this.top = this.right = this.bottom = 0;\n    }\n}\n\n/**@internal */\nclass TileMapAniData {\n    mAniIdArray: any[] = [];\n    mDurationTimeArray: any[] = [];\n    mTileTexSetArr: any[] = [];\n    image: any;\n}\n\n/**@internal */\nclass TileSet {\n\n    firstgid: number = 0;\n    image: string = \"\";\n    imageheight: number = 0;\n    imagewidth: number = 0;\n    margin: number = 0;\n    name: number = 0;\n    properties: any;\n    spacing: number = 0;\n    tileheight: number = 0;\n    tilewidth: number = 0;\n\n    titleoffsetX: number = 0;\n    titleoffsetY: number = 0;\n    tileproperties: any;\n\n    init(data: any): void {\n        this.firstgid = data.firstgid;\n        this.image = data.image;\n        this.imageheight = data.imageheight;\n        this.imagewidth = data.imagewidth;\n        this.margin = data.margin;\n        this.name = data.name;\n        this.properties = data.properties;\n        this.spacing = data.spacing;\n        this.tileheight = data.tileheight;\n        this.tilewidth = data.tilewidth;\n\n        //自定义属性\n        this.tileproperties = data.tileproperties;\n        var tTileoffset: any = data.tileoffset;\n        if (tTileoffset) {\n            this.titleoffsetX = tTileoffset.x;\n            this.titleoffsetY = tTileoffset.y;\n        }\n    }\n}\n\nIMap.TiledMap = TiledMap;"],"mappings":"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"}